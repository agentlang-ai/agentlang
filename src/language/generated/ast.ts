/******************************************************************************
 * This file was generated by langium-cli 3.5.0.
 * DO NOT EDIT MANUALLY!
 ******************************************************************************/

 
import * as langium from 'langium';

export const AgentlangTerminals = {
    ID: /(([_a-zA-Z][\w_]*)(\/([_a-zA-Z][\w_]*))?)/,
    STRING: /(["'])((\\{2})*|(.*?[^\\](\\{2})*))\1/,
    INT: /-?[0-9]+/,
    WS: /\s+/,
    ML_COMMENT: /\/\*[\s\S]*?\*\//,
    SL_COMMENT: /\/\/[^\n\r]*/,
};

export type AgentlangTerminalNames = keyof typeof AgentlangTerminals;

export type AgentlangKeywordNames =
    | "("
    | ")"
    | "*"
    | "+"
    | ","
    | "-"
    | "."
    | "/"
    | ":"
    | ";"
    | "<"
    | "<="
    | "<>"
    | "="
    | ">"
    | ">="
    | "?"
    | "@"
    | "@after"
    | "@async"
    | "@before"
    | "@enum"
    | "@expr"
    | "@meta"
    | "@oneof"
    | "@rbac"
    | "@ref"
    | "@with_unique"
    | "["
    | "]"
    | "allow"
    | "and"
    | "as"
    | "await"
    | "between"
    | "catch"
    | "contains"
    | "create"
    | "delete"
    | "else"
    | "entity"
    | "error"
    | "event"
    | "extends"
    | "false"
    | "for"
    | "if"
    | "import"
    | "in"
    | "into"
    | "like"
    | "module"
    | "not"
    | "not_found"
    | "or"
    | "purge"
    | "read"
    | "record"
    | "relationship"
    | "roles"
    | "true"
    | "update"
    | "upsert"
    | "where"
    | "workflow"
    | "{"
    | "}";

export type AgentlangTokenNames = AgentlangTerminalNames | AgentlangKeywordNames;

export type AttributeValueExpression = Expr;

export const AttributeValueExpression = 'AttributeValueExpression';

export function isAttributeValueExpression(item: unknown): item is AttributeValueExpression {
    return reflection.isInstance(item, AttributeValueExpression);
}

export type Boolean = 'false' | 'true';

export function isBoolean(item: unknown): item is Boolean {
    return item === 'true' || item === 'false';
}

export type Decimal = number;

export function isDecimal(item: unknown): item is Decimal {
    return typeof item === 'number';
}

export type Definition = RelationshipDefinition | SchemaDefinition | StandaloneStatement | WorkflowDefinition;

export const Definition = 'Definition';

export function isDefinition(item: unknown): item is Definition {
    return reflection.isInstance(item, Definition);
}

export type Expr = BinExpr | PrimExpr;

export const Expr = 'Expr';

export function isExpr(item: unknown): item is Expr {
    return reflection.isInstance(item, Expr);
}

export type PrimExpr = Group | Literal | NegExpr | NotExpr;

export const PrimExpr = 'PrimExpr';

export function isPrimExpr(item: unknown): item is PrimExpr {
    return reflection.isInstance(item, PrimExpr);
}

export type QueryId = string;

export function isQueryId(item: unknown): item is QueryId {
    return typeof item === 'string';
}

export type Ref = string;

export function isRef(item: unknown): item is Ref {
    return typeof item === 'string';
}

export type SchemaDefinition = EntityDefinition | EventDefinition | RecordDefinition;

export const SchemaDefinition = 'SchemaDefinition';

export function isSchemaDefinition(item: unknown): item is SchemaDefinition {
    return reflection.isInstance(item, SchemaDefinition);
}

export type TaggedId = string;

export function isTaggedId(item: unknown): item is TaggedId {
    return typeof item === 'string';
}

export interface AfterTriggerDefinition extends langium.AstNode {
    readonly $container: PrePostTriggerDefinition;
    readonly $type: 'AfterTriggerDefinition';
    triggers: TriggerDefinition;
}

export const AfterTriggerDefinition = 'AfterTriggerDefinition';

export function isAfterTriggerDefinition(item: unknown): item is AfterTriggerDefinition {
    return reflection.isInstance(item, AfterTriggerDefinition);
}

export interface AliasSpec extends langium.AstNode {
    readonly $container: RuntimeHint;
    readonly $type: 'AliasSpec';
    alias?: string;
    aliases: Array<string>;
}

export const AliasSpec = 'AliasSpec';

export function isAliasSpec(item: unknown): item is AliasSpec {
    return reflection.isInstance(item, AliasSpec);
}

export interface ArrayLiteral extends langium.AstNode {
    readonly $container: Literal;
    readonly $type: 'ArrayLiteral';
    vals: Array<Statement>;
}

export const ArrayLiteral = 'ArrayLiteral';

export function isArrayLiteral(item: unknown): item is ArrayLiteral {
    return reflection.isInstance(item, ArrayLiteral);
}

export interface AsyncFnCall extends langium.AstNode {
    readonly $container: Literal;
    readonly $type: 'AsyncFnCall';
    fnCall: FnCall;
}

export const AsyncFnCall = 'AsyncFnCall';

export function isAsyncFnCall(item: unknown): item is AsyncFnCall {
    return reflection.isInstance(item, AsyncFnCall);
}

export interface AttributeDefinition extends langium.AstNode {
    readonly $container: RecordSchemaDefinition;
    readonly $type: 'AttributeDefinition';
    arrayType?: string;
    enumSpec?: EnumSpec;
    expr?: Expr;
    name: string;
    oneOfSpec?: OneOfSpec;
    properties: Array<PropertyDefinition>;
    refSpec?: RefSpec;
    type?: string;
}

export const AttributeDefinition = 'AttributeDefinition';

export function isAttributeDefinition(item: unknown): item is AttributeDefinition {
    return reflection.isInstance(item, AttributeDefinition);
}

export interface BeforeTriggerDefinition extends langium.AstNode {
    readonly $container: PrePostTriggerDefinition;
    readonly $type: 'BeforeTriggerDefinition';
    triggers: TriggerDefinition;
}

export const BeforeTriggerDefinition = 'BeforeTriggerDefinition';

export function isBeforeTriggerDefinition(item: unknown): item is BeforeTriggerDefinition {
    return reflection.isInstance(item, BeforeTriggerDefinition);
}

export interface BinExpr extends langium.AstNode {
    readonly $container: AttributeDefinition | BinExpr | Group | If | NegExpr | NotExpr | SetAttribute;
    readonly $type: 'BinExpr';
    e1: Expr | PrimExpr;
    e2: Expr | PrimExpr;
    op: '*' | '+' | '-' | '/' | '<' | '<=' | '<>' | '=' | '>' | '>=' | 'and' | 'in' | 'like' | 'or';
}

export const BinExpr = 'BinExpr';

export function isBinExpr(item: unknown): item is BinExpr {
    return reflection.isInstance(item, BinExpr);
}

export interface CatchSpec extends langium.AstNode {
    readonly $container: RuntimeHint;
    readonly $type: 'CatchSpec';
    handlers: Array<Handler>;
}

export const CatchSpec = 'CatchSpec';

export function isCatchSpec(item: unknown): item is CatchSpec {
    return reflection.isInstance(item, CatchSpec);
}

export interface CompositeUniqueDefinition extends langium.AstNode {
    readonly $container: RecordExtraDefinition;
    readonly $type: 'CompositeUniqueDefinition';
    attrs: Array<string>;
}

export const CompositeUniqueDefinition = 'CompositeUniqueDefinition';

export function isCompositeUniqueDefinition(item: unknown): item is CompositeUniqueDefinition {
    return reflection.isInstance(item, CompositeUniqueDefinition);
}

export interface CrudMap extends langium.AstNode {
    readonly $container: Pattern | Upsert;
    readonly $type: 'CrudMap';
    attributes: Array<SetAttribute>;
    into?: SelectIntoSpec;
    name: QueryId | string;
    properties: Array<PropertyDefinition>;
    relationships: Array<RelationshipPattern>;
}

export const CrudMap = 'CrudMap';

export function isCrudMap(item: unknown): item is CrudMap {
    return reflection.isInstance(item, CrudMap);
}

export interface Delete extends langium.AstNode {
    readonly $container: Pattern;
    readonly $type: 'Delete';
    pattern: Pattern;
}

export const Delete = 'Delete';

export function isDelete(item: unknown): item is Delete {
    return reflection.isInstance(item, Delete);
}

export interface Else extends langium.AstNode {
    readonly $container: If;
    readonly $type: 'Else';
    statements: Array<Statement>;
}

export const Else = 'Else';

export function isElse(item: unknown): item is Else {
    return reflection.isInstance(item, Else);
}

export interface EntityDefinition extends langium.AstNode {
    readonly $container: ModuleDefinition;
    readonly $type: 'EntityDefinition';
    extends?: ExtendsClause;
    name: string;
    schema: RecordSchemaDefinition;
}

export const EntityDefinition = 'EntityDefinition';

export function isEntityDefinition(item: unknown): item is EntityDefinition {
    return reflection.isInstance(item, EntityDefinition);
}

export interface EnumSpec extends langium.AstNode {
    readonly $container: AttributeDefinition;
    readonly $type: 'EnumSpec';
    values: Array<string>;
}

export const EnumSpec = 'EnumSpec';

export function isEnumSpec(item: unknown): item is EnumSpec {
    return reflection.isInstance(item, EnumSpec);
}

export interface EventDefinition extends langium.AstNode {
    readonly $container: ModuleDefinition;
    readonly $type: 'EventDefinition';
    extends?: ExtendsClause;
    name: string;
    schema: RecordSchemaDefinition;
}

export const EventDefinition = 'EventDefinition';

export function isEventDefinition(item: unknown): item is EventDefinition {
    return reflection.isInstance(item, EventDefinition);
}

export interface ExtendsClause extends langium.AstNode {
    readonly $container: EntityDefinition | EventDefinition | RecordDefinition;
    readonly $type: 'ExtendsClause';
    parentName: string;
}

export const ExtendsClause = 'ExtendsClause';

export function isExtendsClause(item: unknown): item is ExtendsClause {
    return reflection.isInstance(item, ExtendsClause);
}

export interface FnCall extends langium.AstNode {
    readonly $container: AsyncFnCall | Literal;
    readonly $type: 'FnCall';
    args: Array<Literal>;
    name: Ref | string;
}

export const FnCall = 'FnCall';

export function isFnCall(item: unknown): item is FnCall {
    return reflection.isInstance(item, FnCall);
}

export interface ForEach extends langium.AstNode {
    readonly $container: Pattern;
    readonly $type: 'ForEach';
    src: Pattern;
    statements: Array<Statement>;
    var: string;
}

export const ForEach = 'ForEach';

export function isForEach(item: unknown): item is ForEach {
    return reflection.isInstance(item, ForEach);
}

export interface FullTextSearch extends langium.AstNode {
    readonly $container: Pattern;
    readonly $type: 'FullTextSearch';
    name: QueryId;
    options?: MapLiteral;
    query: Literal;
}

export const FullTextSearch = 'FullTextSearch';

export function isFullTextSearch(item: unknown): item is FullTextSearch {
    return reflection.isInstance(item, FullTextSearch);
}

export interface Group extends langium.AstNode {
    readonly $container: AttributeDefinition | BinExpr | Group | If | NegExpr | NotExpr | SetAttribute;
    readonly $type: 'Group';
    ge: Expr;
}

export const Group = 'Group';

export function isGroup(item: unknown): item is Group {
    return reflection.isInstance(item, Group);
}

export interface Handler extends langium.AstNode {
    readonly $container: CatchSpec;
    readonly $type: 'Handler';
    except: 'error' | 'not_found';
    stmt: Statement;
}

export const Handler = 'Handler';

export function isHandler(item: unknown): item is Handler {
    return reflection.isInstance(item, Handler);
}

export interface If extends langium.AstNode {
    readonly $container: Pattern;
    readonly $type: 'If';
    cond: Expr;
    else?: Else;
    statements: Array<Statement>;
}

export const If = 'If';

export function isIf(item: unknown): item is If {
    return reflection.isInstance(item, If);
}

export interface Import extends langium.AstNode {
    readonly $container: ModuleDefinition;
    readonly $type: 'Import';
    name: string;
    path: string;
}

export const Import = 'Import';

export function isImport(item: unknown): item is Import {
    return reflection.isInstance(item, Import);
}

export interface KvPair extends langium.AstNode {
    readonly $container: KvPairs;
    readonly $type: 'KvPair';
    key?: string;
    value: Literal;
}

export const KvPair = 'KvPair';

export function isKvPair(item: unknown): item is KvPair {
    return reflection.isInstance(item, KvPair);
}

export interface KvPairs extends langium.AstNode {
    readonly $container: PropertyDefinition;
    readonly $type: 'KvPairs';
    pairs: Array<KvPair>;
}

export const KvPairs = 'KvPairs';

export function isKvPairs(item: unknown): item is KvPairs {
    return reflection.isInstance(item, KvPairs);
}

export interface Literal extends langium.AstNode {
    readonly $container: AttributeDefinition | BinExpr | FnCall | FullTextSearch | Group | If | KvPair | MapEntry | NegExpr | NotExpr | Pattern | SetAttribute;
    readonly $type: 'Literal';
    array?: ArrayLiteral;
    asyncFnCall?: AsyncFnCall;
    bool?: Boolean;
    fnCall?: FnCall;
    id?: string;
    map?: MapLiteral;
    num?: Decimal;
    ref?: Ref;
    str?: string;
}

export const Literal = 'Literal';

export function isLiteral(item: unknown): item is Literal {
    return reflection.isInstance(item, Literal);
}

export interface MapEntry extends langium.AstNode {
    readonly $container: MapLiteral;
    readonly $type: 'MapEntry';
    key: MapKey;
    value: Literal;
}

export const MapEntry = 'MapEntry';

export function isMapEntry(item: unknown): item is MapEntry {
    return reflection.isInstance(item, MapEntry);
}

export interface MapKey extends langium.AstNode {
    readonly $container: MapEntry;
    readonly $type: 'MapKey';
    bool?: Boolean;
    num?: Decimal;
    str?: string;
}

export const MapKey = 'MapKey';

export function isMapKey(item: unknown): item is MapKey {
    return reflection.isInstance(item, MapKey);
}

export interface MapLiteral extends langium.AstNode {
    readonly $container: FullTextSearch | Literal | MetaDefinition;
    readonly $type: 'MapLiteral';
    entries: Array<MapEntry>;
}

export const MapLiteral = 'MapLiteral';

export function isMapLiteral(item: unknown): item is MapLiteral {
    return reflection.isInstance(item, MapLiteral);
}

export interface MetaDefinition extends langium.AstNode {
    readonly $container: RecordExtraDefinition;
    readonly $type: 'MetaDefinition';
    spec: MapLiteral;
}

export const MetaDefinition = 'MetaDefinition';

export function isMetaDefinition(item: unknown): item is MetaDefinition {
    return reflection.isInstance(item, MetaDefinition);
}

export interface ModuleDefinition extends langium.AstNode {
    readonly $type: 'ModuleDefinition';
    defs: Array<Definition>;
    imports: Array<Import>;
    name: string;
}

export const ModuleDefinition = 'ModuleDefinition';

export function isModuleDefinition(item: unknown): item is ModuleDefinition {
    return reflection.isInstance(item, ModuleDefinition);
}

export interface NegExpr extends langium.AstNode {
    readonly $container: AttributeDefinition | BinExpr | Group | If | NegExpr | NotExpr | SetAttribute;
    readonly $type: 'NegExpr';
    ne: Expr;
}

export const NegExpr = 'NegExpr';

export function isNegExpr(item: unknown): item is NegExpr {
    return reflection.isInstance(item, NegExpr);
}

export interface NodeDefinition extends langium.AstNode {
    readonly $container: RelNodes;
    readonly $type: 'NodeDefinition';
    alias?: string;
    name: string;
}

export const NodeDefinition = 'NodeDefinition';

export function isNodeDefinition(item: unknown): item is NodeDefinition {
    return reflection.isInstance(item, NodeDefinition);
}

export interface NotExpr extends langium.AstNode {
    readonly $container: AttributeDefinition | BinExpr | Group | If | NegExpr | NotExpr | SetAttribute;
    readonly $type: 'NotExpr';
    ne: Expr;
}

export const NotExpr = 'NotExpr';

export function isNotExpr(item: unknown): item is NotExpr {
    return reflection.isInstance(item, NotExpr);
}

export interface OneOfSpec extends langium.AstNode {
    readonly $container: AttributeDefinition;
    readonly $type: 'OneOfSpec';
    ref: Ref;
}

export const OneOfSpec = 'OneOfSpec';

export function isOneOfSpec(item: unknown): item is OneOfSpec {
    return reflection.isInstance(item, OneOfSpec);
}

export interface Pattern extends langium.AstNode {
    readonly $container: Delete | ForEach | Purge | RelationshipPattern | Statement;
    readonly $type: 'Pattern';
    crudMap?: CrudMap;
    delete?: Delete;
    forEach?: ForEach;
    fullTextSearch?: FullTextSearch;
    if?: If;
    literal?: Literal;
    purge?: Purge;
    upsert?: Upsert;
}

export const Pattern = 'Pattern';

export function isPattern(item: unknown): item is Pattern {
    return reflection.isInstance(item, Pattern);
}

export interface PrePostTriggerDefinition extends langium.AstNode {
    readonly $container: RecordExtraDefinition;
    readonly $type: 'PrePostTriggerDefinition';
    after?: AfterTriggerDefinition;
    before?: BeforeTriggerDefinition;
}

export const PrePostTriggerDefinition = 'PrePostTriggerDefinition';

export function isPrePostTriggerDefinition(item: unknown): item is PrePostTriggerDefinition {
    return reflection.isInstance(item, PrePostTriggerDefinition);
}

export interface PropertyDefinition extends langium.AstNode {
    readonly $container: AttributeDefinition | CrudMap | RelationshipDefinition;
    readonly $type: 'PropertyDefinition';
    name: TaggedId;
    value?: KvPairs;
}

export const PropertyDefinition = 'PropertyDefinition';

export function isPropertyDefinition(item: unknown): item is PropertyDefinition {
    return reflection.isInstance(item, PropertyDefinition);
}

export interface Purge extends langium.AstNode {
    readonly $container: Pattern;
    readonly $type: 'Purge';
    pattern: Pattern;
}

export const Purge = 'Purge';

export function isPurge(item: unknown): item is Purge {
    return reflection.isInstance(item, Purge);
}

export interface RbacAllowSpec extends langium.AstNode {
    readonly $container: RbacSpecEntry;
    readonly $type: 'RbacAllowSpec';
    oprs: Array<RbacOpr>;
}

export const RbacAllowSpec = 'RbacAllowSpec';

export function isRbacAllowSpec(item: unknown): item is RbacAllowSpec {
    return reflection.isInstance(item, RbacAllowSpec);
}

export interface RbacExpressionSpec extends langium.AstNode {
    readonly $container: RbacSpecEntry;
    readonly $type: 'RbacExpressionSpec';
    lhs: Ref;
    rhs: Ref;
}

export const RbacExpressionSpec = 'RbacExpressionSpec';

export function isRbacExpressionSpec(item: unknown): item is RbacExpressionSpec {
    return reflection.isInstance(item, RbacExpressionSpec);
}

export interface RbacOpr extends langium.AstNode {
    readonly $container: RbacAllowSpec;
    readonly $type: 'RbacOpr';
    value: 'create' | 'delete' | 'read' | 'update';
}

export const RbacOpr = 'RbacOpr';

export function isRbacOpr(item: unknown): item is RbacOpr {
    return reflection.isInstance(item, RbacOpr);
}

export interface RbacRolesSpec extends langium.AstNode {
    readonly $container: RbacSpecEntry;
    readonly $type: 'RbacRolesSpec';
    roles: Array<string>;
}

export const RbacRolesSpec = 'RbacRolesSpec';

export function isRbacRolesSpec(item: unknown): item is RbacRolesSpec {
    return reflection.isInstance(item, RbacRolesSpec);
}

export interface RbacSpecDefinition extends langium.AstNode {
    readonly $container: RecordExtraDefinition;
    readonly $type: 'RbacSpecDefinition';
    specEntries: Array<RbacSpecEntries>;
}

export const RbacSpecDefinition = 'RbacSpecDefinition';

export function isRbacSpecDefinition(item: unknown): item is RbacSpecDefinition {
    return reflection.isInstance(item, RbacSpecDefinition);
}

export interface RbacSpecEntries extends langium.AstNode {
    readonly $container: RbacSpecDefinition;
    readonly $type: 'RbacSpecEntries';
    entries: Array<RbacSpecEntry>;
}

export const RbacSpecEntries = 'RbacSpecEntries';

export function isRbacSpecEntries(item: unknown): item is RbacSpecEntries {
    return reflection.isInstance(item, RbacSpecEntries);
}

export interface RbacSpecEntry extends langium.AstNode {
    readonly $container: RbacSpecEntries;
    readonly $type: 'RbacSpecEntry';
    allow?: RbacAllowSpec;
    expr?: RbacExpressionSpec;
    role?: RbacRolesSpec;
}

export const RbacSpecEntry = 'RbacSpecEntry';

export function isRbacSpecEntry(item: unknown): item is RbacSpecEntry {
    return reflection.isInstance(item, RbacSpecEntry);
}

export interface RecordDefinition extends langium.AstNode {
    readonly $container: ModuleDefinition;
    readonly $type: 'RecordDefinition';
    extends?: ExtendsClause;
    name: string;
    schema: RecordSchemaDefinition;
}

export const RecordDefinition = 'RecordDefinition';

export function isRecordDefinition(item: unknown): item is RecordDefinition {
    return reflection.isInstance(item, RecordDefinition);
}

export interface RecordExtraDefinition extends langium.AstNode {
    readonly $container: RecordSchemaDefinition;
    readonly $type: 'RecordExtraDefinition';
    meta?: MetaDefinition;
    prePost?: PrePostTriggerDefinition;
    rbacSpec?: RbacSpecDefinition;
    uq?: CompositeUniqueDefinition;
}

export const RecordExtraDefinition = 'RecordExtraDefinition';

export function isRecordExtraDefinition(item: unknown): item is RecordExtraDefinition {
    return reflection.isInstance(item, RecordExtraDefinition);
}

export interface RecordSchemaDefinition extends langium.AstNode {
    readonly $container: EntityDefinition | EventDefinition | RecordDefinition | RelationshipDefinition;
    readonly $type: 'RecordSchemaDefinition';
    attributes: Array<AttributeDefinition>;
    extras: Array<RecordExtraDefinition>;
}

export const RecordSchemaDefinition = 'RecordSchemaDefinition';

export function isRecordSchemaDefinition(item: unknown): item is RecordSchemaDefinition {
    return reflection.isInstance(item, RecordSchemaDefinition);
}

export interface RefSpec extends langium.AstNode {
    readonly $container: AttributeDefinition;
    readonly $type: 'RefSpec';
    ref: string;
}

export const RefSpec = 'RefSpec';

export function isRefSpec(item: unknown): item is RefSpec {
    return reflection.isInstance(item, RefSpec);
}

export interface RelationshipDefinition extends langium.AstNode {
    readonly $container: ModuleDefinition;
    readonly $type: 'RelationshipDefinition';
    name: string;
    nodes: RelNodes;
    properties: Array<PropertyDefinition>;
    schema?: RecordSchemaDefinition;
    type: 'between' | 'contains';
}

export const RelationshipDefinition = 'RelationshipDefinition';

export function isRelationshipDefinition(item: unknown): item is RelationshipDefinition {
    return reflection.isInstance(item, RelationshipDefinition);
}

export interface RelationshipPattern extends langium.AstNode {
    readonly $container: CrudMap;
    readonly $type: 'RelationshipPattern';
    name: string;
    pattern: Pattern;
}

export const RelationshipPattern = 'RelationshipPattern';

export function isRelationshipPattern(item: unknown): item is RelationshipPattern {
    return reflection.isInstance(item, RelationshipPattern);
}

export interface RelNodes extends langium.AstNode {
    readonly $container: RelationshipDefinition;
    readonly $type: 'RelNodes';
    node1: NodeDefinition;
    node2: NodeDefinition;
}

export const RelNodes = 'RelNodes';

export function isRelNodes(item: unknown): item is RelNodes {
    return reflection.isInstance(item, RelNodes);
}

export interface RuntimeHint extends langium.AstNode {
    readonly $container: Statement;
    readonly $type: 'RuntimeHint';
    aliasSpec?: AliasSpec;
    catchSpec?: CatchSpec;
}

export const RuntimeHint = 'RuntimeHint';

export function isRuntimeHint(item: unknown): item is RuntimeHint {
    return reflection.isInstance(item, RuntimeHint);
}

export interface SelectIntoEntry extends langium.AstNode {
    readonly $container: SelectIntoSpec;
    readonly $type: 'SelectIntoEntry';
    alias: string;
    attribute: Ref;
}

export const SelectIntoEntry = 'SelectIntoEntry';

export function isSelectIntoEntry(item: unknown): item is SelectIntoEntry {
    return reflection.isInstance(item, SelectIntoEntry);
}

export interface SelectIntoSpec extends langium.AstNode {
    readonly $container: CrudMap;
    readonly $type: 'SelectIntoSpec';
    entries: Array<SelectIntoEntry>;
}

export const SelectIntoSpec = 'SelectIntoSpec';

export function isSelectIntoSpec(item: unknown): item is SelectIntoSpec {
    return reflection.isInstance(item, SelectIntoSpec);
}

export interface SetAttribute extends langium.AstNode {
    readonly $container: CrudMap;
    readonly $type: 'SetAttribute';
    name: QueryId;
    op?: '<' | '<=' | '<>' | '=' | '>' | '>=' | 'between' | 'in' | 'like';
    value: AttributeValueExpression;
}

export const SetAttribute = 'SetAttribute';

export function isSetAttribute(item: unknown): item is SetAttribute {
    return reflection.isInstance(item, SetAttribute);
}

export interface StandaloneStatement extends langium.AstNode {
    readonly $container: ModuleDefinition;
    readonly $type: 'StandaloneStatement';
    stmt: Statement;
}

export const StandaloneStatement = 'StandaloneStatement';

export function isStandaloneStatement(item: unknown): item is StandaloneStatement {
    return reflection.isInstance(item, StandaloneStatement);
}

export interface Statement extends langium.AstNode {
    readonly $container: ArrayLiteral | Else | ForEach | Handler | If | StandaloneStatement | WorkflowDefinition;
    readonly $type: 'Statement';
    hints: Array<RuntimeHint>;
    pattern: Pattern;
}

export const Statement = 'Statement';

export function isStatement(item: unknown): item is Statement {
    return reflection.isInstance(item, Statement);
}

export interface TriggerDefinition extends langium.AstNode {
    readonly $container: AfterTriggerDefinition | BeforeTriggerDefinition;
    readonly $type: 'TriggerDefinition';
    entries: Array<TriggerEntry>;
}

export const TriggerDefinition = 'TriggerDefinition';

export function isTriggerDefinition(item: unknown): item is TriggerDefinition {
    return reflection.isInstance(item, TriggerDefinition);
}

export interface TriggerEntry extends langium.AstNode {
    readonly $container: TriggerDefinition;
    readonly $type: 'TriggerEntry';
    async?: '@async';
    event: string;
    on: 'create' | 'delete' | 'update';
}

export const TriggerEntry = 'TriggerEntry';

export function isTriggerEntry(item: unknown): item is TriggerEntry {
    return reflection.isInstance(item, TriggerEntry);
}

export interface Upsert extends langium.AstNode {
    readonly $container: Pattern;
    readonly $type: 'Upsert';
    pattern: CrudMap;
}

export const Upsert = 'Upsert';

export function isUpsert(item: unknown): item is Upsert {
    return reflection.isInstance(item, Upsert);
}

export interface WorkflowDefinition extends langium.AstNode {
    readonly $container: ModuleDefinition;
    readonly $type: 'WorkflowDefinition';
    name: string;
    statements: Array<Statement>;
}

export const WorkflowDefinition = 'WorkflowDefinition';

export function isWorkflowDefinition(item: unknown): item is WorkflowDefinition {
    return reflection.isInstance(item, WorkflowDefinition);
}

export type AgentlangAstType = {
    AfterTriggerDefinition: AfterTriggerDefinition
    AliasSpec: AliasSpec
    ArrayLiteral: ArrayLiteral
    AsyncFnCall: AsyncFnCall
    AttributeDefinition: AttributeDefinition
    AttributeValueExpression: AttributeValueExpression
    BeforeTriggerDefinition: BeforeTriggerDefinition
    BinExpr: BinExpr
    CatchSpec: CatchSpec
    CompositeUniqueDefinition: CompositeUniqueDefinition
    CrudMap: CrudMap
    Definition: Definition
    Delete: Delete
    Else: Else
    EntityDefinition: EntityDefinition
    EnumSpec: EnumSpec
    EventDefinition: EventDefinition
    Expr: Expr
    ExtendsClause: ExtendsClause
    FnCall: FnCall
    ForEach: ForEach
    FullTextSearch: FullTextSearch
    Group: Group
    Handler: Handler
    If: If
    Import: Import
    KvPair: KvPair
    KvPairs: KvPairs
    Literal: Literal
    MapEntry: MapEntry
    MapKey: MapKey
    MapLiteral: MapLiteral
    MetaDefinition: MetaDefinition
    ModuleDefinition: ModuleDefinition
    NegExpr: NegExpr
    NodeDefinition: NodeDefinition
    NotExpr: NotExpr
    OneOfSpec: OneOfSpec
    Pattern: Pattern
    PrePostTriggerDefinition: PrePostTriggerDefinition
    PrimExpr: PrimExpr
    PropertyDefinition: PropertyDefinition
    Purge: Purge
    RbacAllowSpec: RbacAllowSpec
    RbacExpressionSpec: RbacExpressionSpec
    RbacOpr: RbacOpr
    RbacRolesSpec: RbacRolesSpec
    RbacSpecDefinition: RbacSpecDefinition
    RbacSpecEntries: RbacSpecEntries
    RbacSpecEntry: RbacSpecEntry
    RecordDefinition: RecordDefinition
    RecordExtraDefinition: RecordExtraDefinition
    RecordSchemaDefinition: RecordSchemaDefinition
    RefSpec: RefSpec
    RelNodes: RelNodes
    RelationshipDefinition: RelationshipDefinition
    RelationshipPattern: RelationshipPattern
    RuntimeHint: RuntimeHint
    SchemaDefinition: SchemaDefinition
    SelectIntoEntry: SelectIntoEntry
    SelectIntoSpec: SelectIntoSpec
    SetAttribute: SetAttribute
    StandaloneStatement: StandaloneStatement
    Statement: Statement
    TriggerDefinition: TriggerDefinition
    TriggerEntry: TriggerEntry
    Upsert: Upsert
    WorkflowDefinition: WorkflowDefinition
}

export class AgentlangAstReflection extends langium.AbstractAstReflection {

    getAllTypes(): string[] {
        return [AfterTriggerDefinition, AliasSpec, ArrayLiteral, AsyncFnCall, AttributeDefinition, AttributeValueExpression, BeforeTriggerDefinition, BinExpr, CatchSpec, CompositeUniqueDefinition, CrudMap, Definition, Delete, Else, EntityDefinition, EnumSpec, EventDefinition, Expr, ExtendsClause, FnCall, ForEach, FullTextSearch, Group, Handler, If, Import, KvPair, KvPairs, Literal, MapEntry, MapKey, MapLiteral, MetaDefinition, ModuleDefinition, NegExpr, NodeDefinition, NotExpr, OneOfSpec, Pattern, PrePostTriggerDefinition, PrimExpr, PropertyDefinition, Purge, RbacAllowSpec, RbacExpressionSpec, RbacOpr, RbacRolesSpec, RbacSpecDefinition, RbacSpecEntries, RbacSpecEntry, RecordDefinition, RecordExtraDefinition, RecordSchemaDefinition, RefSpec, RelNodes, RelationshipDefinition, RelationshipPattern, RuntimeHint, SchemaDefinition, SelectIntoEntry, SelectIntoSpec, SetAttribute, StandaloneStatement, Statement, TriggerDefinition, TriggerEntry, Upsert, WorkflowDefinition];
    }

    protected override computeIsSubtype(subtype: string, supertype: string): boolean {
        switch (subtype) {
            case BinExpr:
            case PrimExpr: {
                return this.isSubtype(Expr, supertype);
            }
            case EntityDefinition:
            case EventDefinition:
            case RecordDefinition: {
                return this.isSubtype(SchemaDefinition, supertype);
            }
            case Expr: {
                return this.isSubtype(AttributeValueExpression, supertype);
            }
            case Group:
            case Literal:
            case NegExpr:
            case NotExpr: {
                return this.isSubtype(PrimExpr, supertype);
            }
            case RelationshipDefinition:
            case SchemaDefinition:
            case StandaloneStatement:
            case WorkflowDefinition: {
                return this.isSubtype(Definition, supertype);
            }
            default: {
                return false;
            }
        }
    }

    getReferenceType(refInfo: langium.ReferenceInfo): string {
        const referenceId = `${refInfo.container.$type}:${refInfo.property}`;
        switch (referenceId) {
            default: {
                throw new Error(`${referenceId} is not a valid reference id.`);
            }
        }
    }

    getTypeMetaData(type: string): langium.TypeMetaData {
        switch (type) {
            case AfterTriggerDefinition: {
                return {
                    name: AfterTriggerDefinition,
                    properties: [
                        { name: 'triggers' }
                    ]
                };
            }
            case AliasSpec: {
                return {
                    name: AliasSpec,
                    properties: [
                        { name: 'alias' },
                        { name: 'aliases', defaultValue: [] }
                    ]
                };
            }
            case ArrayLiteral: {
                return {
                    name: ArrayLiteral,
                    properties: [
                        { name: 'vals', defaultValue: [] }
                    ]
                };
            }
            case AsyncFnCall: {
                return {
                    name: AsyncFnCall,
                    properties: [
                        { name: 'fnCall' }
                    ]
                };
            }
            case AttributeDefinition: {
                return {
                    name: AttributeDefinition,
                    properties: [
                        { name: 'arrayType' },
                        { name: 'enumSpec' },
                        { name: 'expr' },
                        { name: 'name' },
                        { name: 'oneOfSpec' },
                        { name: 'properties', defaultValue: [] },
                        { name: 'refSpec' },
                        { name: 'type' }
                    ]
                };
            }
            case BeforeTriggerDefinition: {
                return {
                    name: BeforeTriggerDefinition,
                    properties: [
                        { name: 'triggers' }
                    ]
                };
            }
            case BinExpr: {
                return {
                    name: BinExpr,
                    properties: [
                        { name: 'e1' },
                        { name: 'e2' },
                        { name: 'op' }
                    ]
                };
            }
            case CatchSpec: {
                return {
                    name: CatchSpec,
                    properties: [
                        { name: 'handlers', defaultValue: [] }
                    ]
                };
            }
            case CompositeUniqueDefinition: {
                return {
                    name: CompositeUniqueDefinition,
                    properties: [
                        { name: 'attrs', defaultValue: [] }
                    ]
                };
            }
            case CrudMap: {
                return {
                    name: CrudMap,
                    properties: [
                        { name: 'attributes', defaultValue: [] },
                        { name: 'into' },
                        { name: 'name' },
                        { name: 'properties', defaultValue: [] },
                        { name: 'relationships', defaultValue: [] }
                    ]
                };
            }
            case Delete: {
                return {
                    name: Delete,
                    properties: [
                        { name: 'pattern' }
                    ]
                };
            }
            case Else: {
                return {
                    name: Else,
                    properties: [
                        { name: 'statements', defaultValue: [] }
                    ]
                };
            }
            case EntityDefinition: {
                return {
                    name: EntityDefinition,
                    properties: [
                        { name: 'extends' },
                        { name: 'name' },
                        { name: 'schema' }
                    ]
                };
            }
            case EnumSpec: {
                return {
                    name: EnumSpec,
                    properties: [
                        { name: 'values', defaultValue: [] }
                    ]
                };
            }
            case EventDefinition: {
                return {
                    name: EventDefinition,
                    properties: [
                        { name: 'extends' },
                        { name: 'name' },
                        { name: 'schema' }
                    ]
                };
            }
            case ExtendsClause: {
                return {
                    name: ExtendsClause,
                    properties: [
                        { name: 'parentName' }
                    ]
                };
            }
            case FnCall: {
                return {
                    name: FnCall,
                    properties: [
                        { name: 'args', defaultValue: [] },
                        { name: 'name' }
                    ]
                };
            }
            case ForEach: {
                return {
                    name: ForEach,
                    properties: [
                        { name: 'src' },
                        { name: 'statements', defaultValue: [] },
                        { name: 'var' }
                    ]
                };
            }
            case FullTextSearch: {
                return {
                    name: FullTextSearch,
                    properties: [
                        { name: 'name' },
                        { name: 'options' },
                        { name: 'query' }
                    ]
                };
            }
            case Group: {
                return {
                    name: Group,
                    properties: [
                        { name: 'ge' }
                    ]
                };
            }
            case Handler: {
                return {
                    name: Handler,
                    properties: [
                        { name: 'except' },
                        { name: 'stmt' }
                    ]
                };
            }
            case If: {
                return {
                    name: If,
                    properties: [
                        { name: 'cond' },
                        { name: 'else' },
                        { name: 'statements', defaultValue: [] }
                    ]
                };
            }
            case Import: {
                return {
                    name: Import,
                    properties: [
                        { name: 'name' },
                        { name: 'path' }
                    ]
                };
            }
            case KvPair: {
                return {
                    name: KvPair,
                    properties: [
                        { name: 'key' },
                        { name: 'value' }
                    ]
                };
            }
            case KvPairs: {
                return {
                    name: KvPairs,
                    properties: [
                        { name: 'pairs', defaultValue: [] }
                    ]
                };
            }
            case Literal: {
                return {
                    name: Literal,
                    properties: [
                        { name: 'array' },
                        { name: 'asyncFnCall' },
                        { name: 'bool' },
                        { name: 'fnCall' },
                        { name: 'id' },
                        { name: 'map' },
                        { name: 'num' },
                        { name: 'ref' },
                        { name: 'str' }
                    ]
                };
            }
            case MapEntry: {
                return {
                    name: MapEntry,
                    properties: [
                        { name: 'key' },
                        { name: 'value' }
                    ]
                };
            }
            case MapKey: {
                return {
                    name: MapKey,
                    properties: [
                        { name: 'bool' },
                        { name: 'num' },
                        { name: 'str' }
                    ]
                };
            }
            case MapLiteral: {
                return {
                    name: MapLiteral,
                    properties: [
                        { name: 'entries', defaultValue: [] }
                    ]
                };
            }
            case MetaDefinition: {
                return {
                    name: MetaDefinition,
                    properties: [
                        { name: 'spec' }
                    ]
                };
            }
            case ModuleDefinition: {
                return {
                    name: ModuleDefinition,
                    properties: [
                        { name: 'defs', defaultValue: [] },
                        { name: 'imports', defaultValue: [] },
                        { name: 'name' }
                    ]
                };
            }
            case NegExpr: {
                return {
                    name: NegExpr,
                    properties: [
                        { name: 'ne' }
                    ]
                };
            }
            case NodeDefinition: {
                return {
                    name: NodeDefinition,
                    properties: [
                        { name: 'alias' },
                        { name: 'name' }
                    ]
                };
            }
            case NotExpr: {
                return {
                    name: NotExpr,
                    properties: [
                        { name: 'ne' }
                    ]
                };
            }
            case OneOfSpec: {
                return {
                    name: OneOfSpec,
                    properties: [
                        { name: 'ref' }
                    ]
                };
            }
            case Pattern: {
                return {
                    name: Pattern,
                    properties: [
                        { name: 'crudMap' },
                        { name: 'delete' },
                        { name: 'forEach' },
                        { name: 'fullTextSearch' },
                        { name: 'if' },
                        { name: 'literal' },
                        { name: 'purge' },
                        { name: 'upsert' }
                    ]
                };
            }
            case PrePostTriggerDefinition: {
                return {
                    name: PrePostTriggerDefinition,
                    properties: [
                        { name: 'after' },
                        { name: 'before' }
                    ]
                };
            }
            case PropertyDefinition: {
                return {
                    name: PropertyDefinition,
                    properties: [
                        { name: 'name' },
                        { name: 'value' }
                    ]
                };
            }
            case Purge: {
                return {
                    name: Purge,
                    properties: [
                        { name: 'pattern' }
                    ]
                };
            }
            case RbacAllowSpec: {
                return {
                    name: RbacAllowSpec,
                    properties: [
                        { name: 'oprs', defaultValue: [] }
                    ]
                };
            }
            case RbacExpressionSpec: {
                return {
                    name: RbacExpressionSpec,
                    properties: [
                        { name: 'lhs' },
                        { name: 'rhs' }
                    ]
                };
            }
            case RbacOpr: {
                return {
                    name: RbacOpr,
                    properties: [
                        { name: 'value' }
                    ]
                };
            }
            case RbacRolesSpec: {
                return {
                    name: RbacRolesSpec,
                    properties: [
                        { name: 'roles', defaultValue: [] }
                    ]
                };
            }
            case RbacSpecDefinition: {
                return {
                    name: RbacSpecDefinition,
                    properties: [
                        { name: 'specEntries', defaultValue: [] }
                    ]
                };
            }
            case RbacSpecEntries: {
                return {
                    name: RbacSpecEntries,
                    properties: [
                        { name: 'entries', defaultValue: [] }
                    ]
                };
            }
            case RbacSpecEntry: {
                return {
                    name: RbacSpecEntry,
                    properties: [
                        { name: 'allow' },
                        { name: 'expr' },
                        { name: 'role' }
                    ]
                };
            }
            case RecordDefinition: {
                return {
                    name: RecordDefinition,
                    properties: [
                        { name: 'extends' },
                        { name: 'name' },
                        { name: 'schema' }
                    ]
                };
            }
            case RecordExtraDefinition: {
                return {
                    name: RecordExtraDefinition,
                    properties: [
                        { name: 'meta' },
                        { name: 'prePost' },
                        { name: 'rbacSpec' },
                        { name: 'uq' }
                    ]
                };
            }
            case RecordSchemaDefinition: {
                return {
                    name: RecordSchemaDefinition,
                    properties: [
                        { name: 'attributes', defaultValue: [] },
                        { name: 'extras', defaultValue: [] }
                    ]
                };
            }
            case RefSpec: {
                return {
                    name: RefSpec,
                    properties: [
                        { name: 'ref' }
                    ]
                };
            }
            case RelationshipDefinition: {
                return {
                    name: RelationshipDefinition,
                    properties: [
                        { name: 'name' },
                        { name: 'nodes' },
                        { name: 'properties', defaultValue: [] },
                        { name: 'schema' },
                        { name: 'type' }
                    ]
                };
            }
            case RelationshipPattern: {
                return {
                    name: RelationshipPattern,
                    properties: [
                        { name: 'name' },
                        { name: 'pattern' }
                    ]
                };
            }
            case RelNodes: {
                return {
                    name: RelNodes,
                    properties: [
                        { name: 'node1' },
                        { name: 'node2' }
                    ]
                };
            }
            case RuntimeHint: {
                return {
                    name: RuntimeHint,
                    properties: [
                        { name: 'aliasSpec' },
                        { name: 'catchSpec' }
                    ]
                };
            }
            case SelectIntoEntry: {
                return {
                    name: SelectIntoEntry,
                    properties: [
                        { name: 'alias' },
                        { name: 'attribute' }
                    ]
                };
            }
            case SelectIntoSpec: {
                return {
                    name: SelectIntoSpec,
                    properties: [
                        { name: 'entries', defaultValue: [] }
                    ]
                };
            }
            case SetAttribute: {
                return {
                    name: SetAttribute,
                    properties: [
                        { name: 'name' },
                        { name: 'op' },
                        { name: 'value' }
                    ]
                };
            }
            case StandaloneStatement: {
                return {
                    name: StandaloneStatement,
                    properties: [
                        { name: 'stmt' }
                    ]
                };
            }
            case Statement: {
                return {
                    name: Statement,
                    properties: [
                        { name: 'hints', defaultValue: [] },
                        { name: 'pattern' }
                    ]
                };
            }
            case TriggerDefinition: {
                return {
                    name: TriggerDefinition,
                    properties: [
                        { name: 'entries', defaultValue: [] }
                    ]
                };
            }
            case TriggerEntry: {
                return {
                    name: TriggerEntry,
                    properties: [
                        { name: 'async' },
                        { name: 'event' },
                        { name: 'on' }
                    ]
                };
            }
            case Upsert: {
                return {
                    name: Upsert,
                    properties: [
                        { name: 'pattern' }
                    ]
                };
            }
            case WorkflowDefinition: {
                return {
                    name: WorkflowDefinition,
                    properties: [
                        { name: 'name' },
                        { name: 'statements', defaultValue: [] }
                    ]
                };
            }
            default: {
                return {
                    name: type,
                    properties: []
                };
            }
        }
    }
}

export const reflection = new AgentlangAstReflection();
