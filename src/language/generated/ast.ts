/******************************************************************************
 * This file was generated by langium-cli 3.5.0.
 * DO NOT EDIT MANUALLY!
 ******************************************************************************/

 
import * as langium from 'langium';

export const AgentlangTerminals = {
    ID: /(([_a-zA-Z][\w_]*)(\/([_a-zA-Z][\w_]*))?)/,
    STRING: /(["'])((\\{2})*|(.*?[^\\](\\{2})*))\1/,
    INT: /-?[0-9]+/,
    WS: /\s+/,
    ML_COMMENT: /\/\*[\s\S]*?\*\//,
    SL_COMMENT: /\/\/[^\n\r]*/,
};

export type AgentlangTerminalNames = keyof typeof AgentlangTerminals;

export type AgentlangKeywordNames =
    | "#"
    | "("
    | ")"
    | "*"
    | "+"
    | ","
    | "-"
    | "."
    | "/"
    | ":"
    | ";"
    | "<"
    | "<="
    | "<>"
    | "="
    | ">"
    | ">="
    | "?"
    | "@"
    | "@oneof"
    | "@rbac"
    | "["
    | "]"
    | "allow"
    | "and"
    | "as"
    | "await"
    | "between"
    | "contains"
    | "create"
    | "delete"
    | "else"
    | "entity"
    | "error"
    | "event"
    | "extends"
    | "false"
    | "for"
    | "if"
    | "import"
    | "in"
    | "like"
    | "module"
    | "not"
    | "not_found"
    | "or"
    | "purge"
    | "read"
    | "record"
    | "relationship"
    | "roles"
    | "throws"
    | "true"
    | "update"
    | "upsert"
    | "where"
    | "workflow"
    | "{"
    | "}";

export type AgentlangTokenNames = AgentlangTerminalNames | AgentlangKeywordNames;

export type AttributeValueExpression = Expr;

export const AttributeValueExpression = 'AttributeValueExpression';

export function isAttributeValueExpression(item: unknown): item is AttributeValueExpression {
    return reflection.isInstance(item, AttributeValueExpression);
}

export type Boolean = 'false' | 'true';

export function isBoolean(item: unknown): item is Boolean {
    return item === 'true' || item === 'false';
}

export type Decimal = number;

export function isDecimal(item: unknown): item is Decimal {
    return typeof item === 'number';
}

export type Definition = RelationshipDefinition | SchemaDef | StandaloneStatement | WorkflowDefinition;

export const Definition = 'Definition';

export function isDefinition(item: unknown): item is Definition {
    return reflection.isInstance(item, Definition);
}

export type Expr = BinExpr | PrimExpr;

export const Expr = 'Expr';

export function isExpr(item: unknown): item is Expr {
    return reflection.isInstance(item, Expr);
}

export type Handler = Statement;

export const Handler = 'Handler';

export function isHandler(item: unknown): item is Handler {
    return reflection.isInstance(item, Handler);
}

export type PrimExpr = Group | Literal | NegExpr | NotExpr;

export const PrimExpr = 'PrimExpr';

export function isPrimExpr(item: unknown): item is PrimExpr {
    return reflection.isInstance(item, PrimExpr);
}

export type QueryId = string;

export function isQueryId(item: unknown): item is QueryId {
    return typeof item === 'string';
}

export type Ref = string;

export function isRef(item: unknown): item is Ref {
    return typeof item === 'string';
}

export type SchemaDef = EntityDefinition | EventDefinition | RecordDefinition;

export const SchemaDef = 'SchemaDef';

export function isSchemaDef(item: unknown): item is SchemaDef {
    return reflection.isInstance(item, SchemaDef);
}

export type TaggedId = string;

export function isTaggedId(item: unknown): item is TaggedId {
    return typeof item === 'string';
}

export interface ArrayLiteral extends langium.AstNode {
    readonly $container: Literal;
    readonly $type: 'ArrayLiteral';
    vals: Array<Statement>;
}

export const ArrayLiteral = 'ArrayLiteral';

export function isArrayLiteral(item: unknown): item is ArrayLiteral {
    return reflection.isInstance(item, ArrayLiteral);
}

export interface AsyncFnCall extends langium.AstNode {
    readonly $container: Literal;
    readonly $type: 'AsyncFnCall';
    fnCall: FnCall;
}

export const AsyncFnCall = 'AsyncFnCall';

export function isAsyncFnCall(item: unknown): item is AsyncFnCall {
    return reflection.isInstance(item, AsyncFnCall);
}

export interface AttributeDefinition extends langium.AstNode {
    readonly $container: RecAttrs | RelationshipDefinition;
    readonly $type: 'AttributeDefinition';
    arrayType?: string;
    name: string;
    oneOfSpec?: OneOfSpec;
    properties: Array<PropertyDefinition>;
    type?: string;
}

export const AttributeDefinition = 'AttributeDefinition';

export function isAttributeDefinition(item: unknown): item is AttributeDefinition {
    return reflection.isInstance(item, AttributeDefinition);
}

export interface BinExpr extends langium.AstNode {
    readonly $container: BinExpr | Group | If | NegExpr | NotExpr | SetAttribute;
    readonly $type: 'BinExpr';
    e1: Expr | PrimExpr;
    e2: Expr | PrimExpr;
    op: '*' | '+' | '-' | '/' | '<' | '<=' | '<>' | '=' | '>' | '>=' | 'and' | 'in' | 'like' | 'or';
}

export const BinExpr = 'BinExpr';

export function isBinExpr(item: unknown): item is BinExpr {
    return reflection.isInstance(item, BinExpr);
}

export interface CrudMap extends langium.AstNode {
    readonly $type: 'CrudMap' | 'QueryAllPattern';
    attributes: Array<SetAttribute>;
    name: string;
    properties: Array<PropertyDefinition>;
    relationships: Array<RelationshipPattern>;
}

export const CrudMap = 'CrudMap';

export function isCrudMap(item: unknown): item is CrudMap {
    return reflection.isInstance(item, CrudMap);
}

export interface Delete extends langium.AstNode {
    readonly $container: Pattern;
    readonly $type: 'Delete';
    pattern: Pattern;
}

export const Delete = 'Delete';

export function isDelete(item: unknown): item is Delete {
    return reflection.isInstance(item, Delete);
}

export interface Else extends langium.AstNode {
    readonly $container: If;
    readonly $type: 'Else';
    statements: Array<Statement>;
}

export const Else = 'Else';

export function isElse(item: unknown): item is Else {
    return reflection.isInstance(item, Else);
}

export interface EntityDefinition extends langium.AstNode {
    readonly $container: ModuleDefinition;
    readonly $type: 'EntityDefinition';
    extends?: ExtendsClause;
    name: string;
    schema: RecAttrs;
}

export const EntityDefinition = 'EntityDefinition';

export function isEntityDefinition(item: unknown): item is EntityDefinition {
    return reflection.isInstance(item, EntityDefinition);
}

export interface EventDefinition extends langium.AstNode {
    readonly $container: ModuleDefinition;
    readonly $type: 'EventDefinition';
    extends?: ExtendsClause;
    name: string;
    schema: RecAttrs;
}

export const EventDefinition = 'EventDefinition';

export function isEventDefinition(item: unknown): item is EventDefinition {
    return reflection.isInstance(item, EventDefinition);
}

export interface ExtendsClause extends langium.AstNode {
    readonly $container: EntityDefinition | EventDefinition | RecordDefinition;
    readonly $type: 'ExtendsClause';
    parentName: string;
}

export const ExtendsClause = 'ExtendsClause';

export function isExtendsClause(item: unknown): item is ExtendsClause {
    return reflection.isInstance(item, ExtendsClause);
}

export interface FnCall extends langium.AstNode {
    readonly $container: AsyncFnCall | Literal;
    readonly $type: 'FnCall';
    args: Array<Literal>;
    name: Ref | string;
}

export const FnCall = 'FnCall';

export function isFnCall(item: unknown): item is FnCall {
    return reflection.isInstance(item, FnCall);
}

export interface ForEach extends langium.AstNode {
    readonly $container: Pattern;
    readonly $type: 'ForEach';
    src: Pattern;
    statements: Array<Statement>;
    var: string;
}

export const ForEach = 'ForEach';

export function isForEach(item: unknown): item is ForEach {
    return reflection.isInstance(item, ForEach);
}

export interface Group extends langium.AstNode {
    readonly $container: BinExpr | Group | If | NegExpr | NotExpr | SetAttribute;
    readonly $type: 'Group';
    ge: Expr;
}

export const Group = 'Group';

export function isGroup(item: unknown): item is Group {
    return reflection.isInstance(item, Group);
}

export interface If extends langium.AstNode {
    readonly $container: Pattern;
    readonly $type: 'If';
    cond: Expr;
    else?: Else;
    statements: Array<Statement>;
}

export const If = 'If';

export function isIf(item: unknown): item is If {
    return reflection.isInstance(item, If);
}

export interface Import extends langium.AstNode {
    readonly $container: ModuleDefinition;
    readonly $type: 'Import';
    name: string;
    path: string;
}

export const Import = 'Import';

export function isImport(item: unknown): item is Import {
    return reflection.isInstance(item, Import);
}

export interface KvPair extends langium.AstNode {
    readonly $container: KvPairs;
    readonly $type: 'KvPair';
    key?: string;
    value: Literal;
}

export const KvPair = 'KvPair';

export function isKvPair(item: unknown): item is KvPair {
    return reflection.isInstance(item, KvPair);
}

export interface KvPairs extends langium.AstNode {
    readonly $container: PropertyDefinition;
    readonly $type: 'KvPairs';
    pairs: Array<KvPair>;
}

export const KvPairs = 'KvPairs';

export function isKvPairs(item: unknown): item is KvPairs {
    return reflection.isInstance(item, KvPairs);
}

export interface Literal extends langium.AstNode {
    readonly $container: BinExpr | FnCall | Group | If | KvPair | MapEntry | NegExpr | NotExpr | Pattern | SetAttribute;
    readonly $type: 'Literal';
    array?: ArrayLiteral;
    asyncFnCall?: AsyncFnCall;
    bool?: Boolean;
    fnCall?: FnCall;
    id?: string;
    map?: MapLiteral;
    num?: Decimal;
    ref?: Ref;
    str?: string;
}

export const Literal = 'Literal';

export function isLiteral(item: unknown): item is Literal {
    return reflection.isInstance(item, Literal);
}

export interface MapEntry extends langium.AstNode {
    readonly $container: MapLiteral;
    readonly $type: 'MapEntry';
    key: string;
    value: Literal;
}

export const MapEntry = 'MapEntry';

export function isMapEntry(item: unknown): item is MapEntry {
    return reflection.isInstance(item, MapEntry);
}

export interface MapLiteral extends langium.AstNode {
    readonly $container: Literal;
    readonly $type: 'MapLiteral';
    entries: Array<MapEntry>;
}

export const MapLiteral = 'MapLiteral';

export function isMapLiteral(item: unknown): item is MapLiteral {
    return reflection.isInstance(item, MapLiteral);
}

export interface ModuleDefinition extends langium.AstNode {
    readonly $type: 'ModuleDefinition';
    defs: Array<Definition>;
    imports: Array<Import>;
    name: string;
}

export const ModuleDefinition = 'ModuleDefinition';

export function isModuleDefinition(item: unknown): item is ModuleDefinition {
    return reflection.isInstance(item, ModuleDefinition);
}

export interface NegExpr extends langium.AstNode {
    readonly $container: BinExpr | Group | If | NegExpr | NotExpr | SetAttribute;
    readonly $type: 'NegExpr';
    ne: Expr;
}

export const NegExpr = 'NegExpr';

export function isNegExpr(item: unknown): item is NegExpr {
    return reflection.isInstance(item, NegExpr);
}

export interface NodeDefinition extends langium.AstNode {
    readonly $container: RelNodes;
    readonly $type: 'NodeDefinition';
    alias?: string;
    name: string;
}

export const NodeDefinition = 'NodeDefinition';

export function isNodeDefinition(item: unknown): item is NodeDefinition {
    return reflection.isInstance(item, NodeDefinition);
}

export interface NotExpr extends langium.AstNode {
    readonly $container: BinExpr | Group | If | NegExpr | NotExpr | SetAttribute;
    readonly $type: 'NotExpr';
    ne: Expr;
}

export const NotExpr = 'NotExpr';

export function isNotExpr(item: unknown): item is NotExpr {
    return reflection.isInstance(item, NotExpr);
}

export interface OneOfSpec extends langium.AstNode {
    readonly $container: AttributeDefinition;
    readonly $type: 'OneOfSpec';
    values: Array<string>;
}

export const OneOfSpec = 'OneOfSpec';

export function isOneOfSpec(item: unknown): item is OneOfSpec {
    return reflection.isInstance(item, OneOfSpec);
}

export interface Pattern extends langium.AstNode {
    readonly $container: Delete | ForEach | Purge | RelationshipPattern | Statement;
    readonly $type: 'Pattern';
    crudMap?: CrudMap;
    delete?: Delete;
    forEach?: ForEach;
    if?: If;
    literal?: Literal;
    purge?: Purge;
    upsert?: Upsert;
}

export const Pattern = 'Pattern';

export function isPattern(item: unknown): item is Pattern {
    return reflection.isInstance(item, Pattern);
}

export interface PropertyDefinition extends langium.AstNode {
    readonly $container: AttributeDefinition | CrudMap | RelationshipDefinition;
    readonly $type: 'PropertyDefinition';
    name: TaggedId;
    value?: KvPairs;
}

export const PropertyDefinition = 'PropertyDefinition';

export function isPropertyDefinition(item: unknown): item is PropertyDefinition {
    return reflection.isInstance(item, PropertyDefinition);
}

export interface Purge extends langium.AstNode {
    readonly $container: Pattern;
    readonly $type: 'Purge';
    pattern: Pattern;
}

export const Purge = 'Purge';

export function isPurge(item: unknown): item is Purge {
    return reflection.isInstance(item, Purge);
}

export interface RbacAllowSpec extends langium.AstNode {
    readonly $container: RbacSpecEntry;
    readonly $type: 'RbacAllowSpec';
    oprs: Array<RbacOpr>;
}

export const RbacAllowSpec = 'RbacAllowSpec';

export function isRbacAllowSpec(item: unknown): item is RbacAllowSpec {
    return reflection.isInstance(item, RbacAllowSpec);
}

export interface RbacExpressionSpec extends langium.AstNode {
    readonly $container: RbacSpecEntry;
    readonly $type: 'RbacExpressionSpec';
    lhs: Ref;
    rhs: Ref;
}

export const RbacExpressionSpec = 'RbacExpressionSpec';

export function isRbacExpressionSpec(item: unknown): item is RbacExpressionSpec {
    return reflection.isInstance(item, RbacExpressionSpec);
}

export interface RbacOpr extends langium.AstNode {
    readonly $container: RbacAllowSpec;
    readonly $type: 'RbacOpr';
    value: 'create' | 'delete' | 'read' | 'update';
}

export const RbacOpr = 'RbacOpr';

export function isRbacOpr(item: unknown): item is RbacOpr {
    return reflection.isInstance(item, RbacOpr);
}

export interface RbacRolesSpec extends langium.AstNode {
    readonly $container: RbacSpecEntry;
    readonly $type: 'RbacRolesSpec';
    roles: Array<string>;
}

export const RbacRolesSpec = 'RbacRolesSpec';

export function isRbacRolesSpec(item: unknown): item is RbacRolesSpec {
    return reflection.isInstance(item, RbacRolesSpec);
}

export interface RbacSpecDefinition extends langium.AstNode {
    readonly $container: RecAttrs;
    readonly $type: 'RbacSpecDefinition';
    specEntries: Array<RbacSpecEntries>;
}

export const RbacSpecDefinition = 'RbacSpecDefinition';

export function isRbacSpecDefinition(item: unknown): item is RbacSpecDefinition {
    return reflection.isInstance(item, RbacSpecDefinition);
}

export interface RbacSpecEntries extends langium.AstNode {
    readonly $container: RbacSpecDefinition;
    readonly $type: 'RbacSpecEntries';
    entries: Array<RbacSpecEntry>;
}

export const RbacSpecEntries = 'RbacSpecEntries';

export function isRbacSpecEntries(item: unknown): item is RbacSpecEntries {
    return reflection.isInstance(item, RbacSpecEntries);
}

export interface RbacSpecEntry extends langium.AstNode {
    readonly $container: RbacSpecEntries;
    readonly $type: 'RbacSpecEntry';
    allow?: RbacAllowSpec;
    expr?: RbacExpressionSpec;
    role?: RbacRolesSpec;
}

export const RbacSpecEntry = 'RbacSpecEntry';

export function isRbacSpecEntry(item: unknown): item is RbacSpecEntry {
    return reflection.isInstance(item, RbacSpecEntry);
}

export interface RecAttrs extends langium.AstNode {
    readonly $container: EntityDefinition | EventDefinition | RecordDefinition;
    readonly $type: 'RecAttrs';
    attributes: Array<AttributeDefinition>;
    rbacSpec?: RbacSpecDefinition;
}

export const RecAttrs = 'RecAttrs';

export function isRecAttrs(item: unknown): item is RecAttrs {
    return reflection.isInstance(item, RecAttrs);
}

export interface RecordDefinition extends langium.AstNode {
    readonly $container: ModuleDefinition;
    readonly $type: 'RecordDefinition';
    extends?: ExtendsClause;
    name: string;
    schema: RecAttrs;
}

export const RecordDefinition = 'RecordDefinition';

export function isRecordDefinition(item: unknown): item is RecordDefinition {
    return reflection.isInstance(item, RecordDefinition);
}

export interface RelationshipDefinition extends langium.AstNode {
    readonly $container: ModuleDefinition;
    readonly $type: 'RelationshipDefinition';
    attributes: Array<AttributeDefinition>;
    name: string;
    nodes: RelNodes;
    properties: Array<PropertyDefinition>;
    type: 'between' | 'contains';
}

export const RelationshipDefinition = 'RelationshipDefinition';

export function isRelationshipDefinition(item: unknown): item is RelationshipDefinition {
    return reflection.isInstance(item, RelationshipDefinition);
}

export interface RelationshipPattern extends langium.AstNode {
    readonly $container: CrudMap | QueryAllPattern;
    readonly $type: 'RelationshipPattern';
    name: string;
    pattern: Pattern;
}

export const RelationshipPattern = 'RelationshipPattern';

export function isRelationshipPattern(item: unknown): item is RelationshipPattern {
    return reflection.isInstance(item, RelationshipPattern);
}

export interface RelNodes extends langium.AstNode {
    readonly $container: RelationshipDefinition;
    readonly $type: 'RelNodes';
    node1: NodeDefinition;
    node2: NodeDefinition;
}

export const RelNodes = 'RelNodes';

export function isRelNodes(item: unknown): item is RelNodes {
    return reflection.isInstance(item, RelNodes);
}

export interface SetAttribute extends langium.AstNode {
    readonly $container: CrudMap;
    readonly $type: 'SetAttribute';
    name: QueryId;
    op?: '<' | '<=' | '<>' | '=' | '>' | '>=' | 'between' | 'in' | 'like';
    value: AttributeValueExpression;
}

export const SetAttribute = 'SetAttribute';

export function isSetAttribute(item: unknown): item is SetAttribute {
    return reflection.isInstance(item, SetAttribute);
}

export interface StandaloneStatement extends langium.AstNode {
    readonly $container: ModuleDefinition;
    readonly $type: 'StandaloneStatement';
    stmt: Statement;
}

export const StandaloneStatement = 'StandaloneStatement';

export function isStandaloneStatement(item: unknown): item is StandaloneStatement {
    return reflection.isInstance(item, StandaloneStatement);
}

export interface Statement extends langium.AstNode {
    readonly $container: ArrayLiteral | Else | ForEach | If | StandaloneStatement | Throws | WorkflowDefinition;
    readonly $type: 'Statement';
    alias?: string;
    aliases: Array<string>;
    pattern: Pattern;
    throws?: Throws;
}

export const Statement = 'Statement';

export function isStatement(item: unknown): item is Statement {
    return reflection.isInstance(item, Statement);
}

export interface Throws extends langium.AstNode {
    readonly $container: Statement;
    readonly $type: 'Throws';
    handlers: Array<Handler>;
}

export const Throws = 'Throws';

export function isThrows(item: unknown): item is Throws {
    return reflection.isInstance(item, Throws);
}

export interface Upsert extends langium.AstNode {
    readonly $container: Pattern;
    readonly $type: 'Upsert';
    pattern: CrudMap;
}

export const Upsert = 'Upsert';

export function isUpsert(item: unknown): item is Upsert {
    return reflection.isInstance(item, Upsert);
}

export interface WorkflowDefinition extends langium.AstNode {
    readonly $container: ModuleDefinition;
    readonly $type: 'WorkflowDefinition';
    name: string;
    statements: Array<Statement>;
}

export const WorkflowDefinition = 'WorkflowDefinition';

export function isWorkflowDefinition(item: unknown): item is WorkflowDefinition {
    return reflection.isInstance(item, WorkflowDefinition);
}

export interface QueryAllPattern extends CrudMap {
    readonly $type: 'QueryAllPattern';
    name: QueryId;
    relationships: Array<RelationshipPattern>;
}

export const QueryAllPattern = 'QueryAllPattern';

export function isQueryAllPattern(item: unknown): item is QueryAllPattern {
    return reflection.isInstance(item, QueryAllPattern);
}

export type AgentlangAstType = {
    ArrayLiteral: ArrayLiteral
    AsyncFnCall: AsyncFnCall
    AttributeDefinition: AttributeDefinition
    AttributeValueExpression: AttributeValueExpression
    BinExpr: BinExpr
    CrudMap: CrudMap
    Definition: Definition
    Delete: Delete
    Else: Else
    EntityDefinition: EntityDefinition
    EventDefinition: EventDefinition
    Expr: Expr
    ExtendsClause: ExtendsClause
    FnCall: FnCall
    ForEach: ForEach
    Group: Group
    Handler: Handler
    If: If
    Import: Import
    KvPair: KvPair
    KvPairs: KvPairs
    Literal: Literal
    MapEntry: MapEntry
    MapLiteral: MapLiteral
    ModuleDefinition: ModuleDefinition
    NegExpr: NegExpr
    NodeDefinition: NodeDefinition
    NotExpr: NotExpr
    OneOfSpec: OneOfSpec
    Pattern: Pattern
    PrimExpr: PrimExpr
    PropertyDefinition: PropertyDefinition
    Purge: Purge
    QueryAllPattern: QueryAllPattern
    RbacAllowSpec: RbacAllowSpec
    RbacExpressionSpec: RbacExpressionSpec
    RbacOpr: RbacOpr
    RbacRolesSpec: RbacRolesSpec
    RbacSpecDefinition: RbacSpecDefinition
    RbacSpecEntries: RbacSpecEntries
    RbacSpecEntry: RbacSpecEntry
    RecAttrs: RecAttrs
    RecordDefinition: RecordDefinition
    RelNodes: RelNodes
    RelationshipDefinition: RelationshipDefinition
    RelationshipPattern: RelationshipPattern
    SchemaDef: SchemaDef
    SetAttribute: SetAttribute
    StandaloneStatement: StandaloneStatement
    Statement: Statement
    Throws: Throws
    Upsert: Upsert
    WorkflowDefinition: WorkflowDefinition
}

export class AgentlangAstReflection extends langium.AbstractAstReflection {

    getAllTypes(): string[] {
        return [ArrayLiteral, AsyncFnCall, AttributeDefinition, AttributeValueExpression, BinExpr, CrudMap, Definition, Delete, Else, EntityDefinition, EventDefinition, Expr, ExtendsClause, FnCall, ForEach, Group, Handler, If, Import, KvPair, KvPairs, Literal, MapEntry, MapLiteral, ModuleDefinition, NegExpr, NodeDefinition, NotExpr, OneOfSpec, Pattern, PrimExpr, PropertyDefinition, Purge, QueryAllPattern, RbacAllowSpec, RbacExpressionSpec, RbacOpr, RbacRolesSpec, RbacSpecDefinition, RbacSpecEntries, RbacSpecEntry, RecAttrs, RecordDefinition, RelNodes, RelationshipDefinition, RelationshipPattern, SchemaDef, SetAttribute, StandaloneStatement, Statement, Throws, Upsert, WorkflowDefinition];
    }

    protected override computeIsSubtype(subtype: string, supertype: string): boolean {
        switch (subtype) {
            case BinExpr:
            case PrimExpr: {
                return this.isSubtype(Expr, supertype);
            }
            case EntityDefinition:
            case EventDefinition:
            case RecordDefinition: {
                return this.isSubtype(SchemaDef, supertype);
            }
            case Expr: {
                return this.isSubtype(AttributeValueExpression, supertype);
            }
            case Group:
            case Literal:
            case NegExpr:
            case NotExpr: {
                return this.isSubtype(PrimExpr, supertype);
            }
            case QueryAllPattern: {
                return this.isSubtype(CrudMap, supertype);
            }
            case RelationshipDefinition:
            case SchemaDef:
            case StandaloneStatement:
            case WorkflowDefinition: {
                return this.isSubtype(Definition, supertype);
            }
            case Statement: {
                return this.isSubtype(Handler, supertype);
            }
            default: {
                return false;
            }
        }
    }

    getReferenceType(refInfo: langium.ReferenceInfo): string {
        const referenceId = `${refInfo.container.$type}:${refInfo.property}`;
        switch (referenceId) {
            default: {
                throw new Error(`${referenceId} is not a valid reference id.`);
            }
        }
    }

    getTypeMetaData(type: string): langium.TypeMetaData {
        switch (type) {
            case ArrayLiteral: {
                return {
                    name: ArrayLiteral,
                    properties: [
                        { name: 'vals', defaultValue: [] }
                    ]
                };
            }
            case AsyncFnCall: {
                return {
                    name: AsyncFnCall,
                    properties: [
                        { name: 'fnCall' }
                    ]
                };
            }
            case AttributeDefinition: {
                return {
                    name: AttributeDefinition,
                    properties: [
                        { name: 'arrayType' },
                        { name: 'name' },
                        { name: 'oneOfSpec' },
                        { name: 'properties', defaultValue: [] },
                        { name: 'type' }
                    ]
                };
            }
            case BinExpr: {
                return {
                    name: BinExpr,
                    properties: [
                        { name: 'e1' },
                        { name: 'e2' },
                        { name: 'op' }
                    ]
                };
            }
            case CrudMap: {
                return {
                    name: CrudMap,
                    properties: [
                        { name: 'attributes', defaultValue: [] },
                        { name: 'name' },
                        { name: 'properties', defaultValue: [] },
                        { name: 'relationships', defaultValue: [] }
                    ]
                };
            }
            case Delete: {
                return {
                    name: Delete,
                    properties: [
                        { name: 'pattern' }
                    ]
                };
            }
            case Else: {
                return {
                    name: Else,
                    properties: [
                        { name: 'statements', defaultValue: [] }
                    ]
                };
            }
            case EntityDefinition: {
                return {
                    name: EntityDefinition,
                    properties: [
                        { name: 'extends' },
                        { name: 'name' },
                        { name: 'schema' }
                    ]
                };
            }
            case EventDefinition: {
                return {
                    name: EventDefinition,
                    properties: [
                        { name: 'extends' },
                        { name: 'name' },
                        { name: 'schema' }
                    ]
                };
            }
            case ExtendsClause: {
                return {
                    name: ExtendsClause,
                    properties: [
                        { name: 'parentName' }
                    ]
                };
            }
            case FnCall: {
                return {
                    name: FnCall,
                    properties: [
                        { name: 'args', defaultValue: [] },
                        { name: 'name' }
                    ]
                };
            }
            case ForEach: {
                return {
                    name: ForEach,
                    properties: [
                        { name: 'src' },
                        { name: 'statements', defaultValue: [] },
                        { name: 'var' }
                    ]
                };
            }
            case Group: {
                return {
                    name: Group,
                    properties: [
                        { name: 'ge' }
                    ]
                };
            }
            case If: {
                return {
                    name: If,
                    properties: [
                        { name: 'cond' },
                        { name: 'else' },
                        { name: 'statements', defaultValue: [] }
                    ]
                };
            }
            case Import: {
                return {
                    name: Import,
                    properties: [
                        { name: 'name' },
                        { name: 'path' }
                    ]
                };
            }
            case KvPair: {
                return {
                    name: KvPair,
                    properties: [
                        { name: 'key' },
                        { name: 'value' }
                    ]
                };
            }
            case KvPairs: {
                return {
                    name: KvPairs,
                    properties: [
                        { name: 'pairs', defaultValue: [] }
                    ]
                };
            }
            case Literal: {
                return {
                    name: Literal,
                    properties: [
                        { name: 'array' },
                        { name: 'asyncFnCall' },
                        { name: 'bool' },
                        { name: 'fnCall' },
                        { name: 'id' },
                        { name: 'map' },
                        { name: 'num' },
                        { name: 'ref' },
                        { name: 'str' }
                    ]
                };
            }
            case MapEntry: {
                return {
                    name: MapEntry,
                    properties: [
                        { name: 'key' },
                        { name: 'value' }
                    ]
                };
            }
            case MapLiteral: {
                return {
                    name: MapLiteral,
                    properties: [
                        { name: 'entries', defaultValue: [] }
                    ]
                };
            }
            case ModuleDefinition: {
                return {
                    name: ModuleDefinition,
                    properties: [
                        { name: 'defs', defaultValue: [] },
                        { name: 'imports', defaultValue: [] },
                        { name: 'name' }
                    ]
                };
            }
            case NegExpr: {
                return {
                    name: NegExpr,
                    properties: [
                        { name: 'ne' }
                    ]
                };
            }
            case NodeDefinition: {
                return {
                    name: NodeDefinition,
                    properties: [
                        { name: 'alias' },
                        { name: 'name' }
                    ]
                };
            }
            case NotExpr: {
                return {
                    name: NotExpr,
                    properties: [
                        { name: 'ne' }
                    ]
                };
            }
            case OneOfSpec: {
                return {
                    name: OneOfSpec,
                    properties: [
                        { name: 'values', defaultValue: [] }
                    ]
                };
            }
            case Pattern: {
                return {
                    name: Pattern,
                    properties: [
                        { name: 'crudMap' },
                        { name: 'delete' },
                        { name: 'forEach' },
                        { name: 'if' },
                        { name: 'literal' },
                        { name: 'purge' },
                        { name: 'upsert' }
                    ]
                };
            }
            case PropertyDefinition: {
                return {
                    name: PropertyDefinition,
                    properties: [
                        { name: 'name' },
                        { name: 'value' }
                    ]
                };
            }
            case Purge: {
                return {
                    name: Purge,
                    properties: [
                        { name: 'pattern' }
                    ]
                };
            }
            case RbacAllowSpec: {
                return {
                    name: RbacAllowSpec,
                    properties: [
                        { name: 'oprs', defaultValue: [] }
                    ]
                };
            }
            case RbacExpressionSpec: {
                return {
                    name: RbacExpressionSpec,
                    properties: [
                        { name: 'lhs' },
                        { name: 'rhs' }
                    ]
                };
            }
            case RbacOpr: {
                return {
                    name: RbacOpr,
                    properties: [
                        { name: 'value' }
                    ]
                };
            }
            case RbacRolesSpec: {
                return {
                    name: RbacRolesSpec,
                    properties: [
                        { name: 'roles', defaultValue: [] }
                    ]
                };
            }
            case RbacSpecDefinition: {
                return {
                    name: RbacSpecDefinition,
                    properties: [
                        { name: 'specEntries', defaultValue: [] }
                    ]
                };
            }
            case RbacSpecEntries: {
                return {
                    name: RbacSpecEntries,
                    properties: [
                        { name: 'entries', defaultValue: [] }
                    ]
                };
            }
            case RbacSpecEntry: {
                return {
                    name: RbacSpecEntry,
                    properties: [
                        { name: 'allow' },
                        { name: 'expr' },
                        { name: 'role' }
                    ]
                };
            }
            case RecAttrs: {
                return {
                    name: RecAttrs,
                    properties: [
                        { name: 'attributes', defaultValue: [] },
                        { name: 'rbacSpec' }
                    ]
                };
            }
            case RecordDefinition: {
                return {
                    name: RecordDefinition,
                    properties: [
                        { name: 'extends' },
                        { name: 'name' },
                        { name: 'schema' }
                    ]
                };
            }
            case RelationshipDefinition: {
                return {
                    name: RelationshipDefinition,
                    properties: [
                        { name: 'attributes', defaultValue: [] },
                        { name: 'name' },
                        { name: 'nodes' },
                        { name: 'properties', defaultValue: [] },
                        { name: 'type' }
                    ]
                };
            }
            case RelationshipPattern: {
                return {
                    name: RelationshipPattern,
                    properties: [
                        { name: 'name' },
                        { name: 'pattern' }
                    ]
                };
            }
            case RelNodes: {
                return {
                    name: RelNodes,
                    properties: [
                        { name: 'node1' },
                        { name: 'node2' }
                    ]
                };
            }
            case SetAttribute: {
                return {
                    name: SetAttribute,
                    properties: [
                        { name: 'name' },
                        { name: 'op' },
                        { name: 'value' }
                    ]
                };
            }
            case StandaloneStatement: {
                return {
                    name: StandaloneStatement,
                    properties: [
                        { name: 'stmt' }
                    ]
                };
            }
            case Statement: {
                return {
                    name: Statement,
                    properties: [
                        { name: 'alias' },
                        { name: 'aliases', defaultValue: [] },
                        { name: 'pattern' },
                        { name: 'throws' }
                    ]
                };
            }
            case Throws: {
                return {
                    name: Throws,
                    properties: [
                        { name: 'handlers', defaultValue: [] }
                    ]
                };
            }
            case Upsert: {
                return {
                    name: Upsert,
                    properties: [
                        { name: 'pattern' }
                    ]
                };
            }
            case WorkflowDefinition: {
                return {
                    name: WorkflowDefinition,
                    properties: [
                        { name: 'name' },
                        { name: 'statements', defaultValue: [] }
                    ]
                };
            }
            case QueryAllPattern: {
                return {
                    name: QueryAllPattern,
                    properties: [
                        { name: 'attributes', defaultValue: [] },
                        { name: 'name' },
                        { name: 'properties', defaultValue: [] },
                        { name: 'relationships', defaultValue: [] }
                    ]
                };
            }
            default: {
                return {
                    name: type,
                    properties: []
                };
            }
        }
    }
}

export const reflection = new AgentlangAstReflection();
