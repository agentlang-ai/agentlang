/******************************************************************************
 * This file was generated by langium-cli 4.2.0.
 * DO NOT EDIT MANUALLY!
 ******************************************************************************/

 
import * as langium from 'langium';

export const AgentlangTerminals = {
    ID: /(?:[_a-zA-Z][\w_]*)(\/(?:[_a-zA-Z][\w_]*))?/,
    QUOTED_STRING: /"(\\(?:[\s\S])|(?:(?!(\\|"|\r|\n))[\s\S]*?)|\r?\n)*"/,
    TICK_QUOTED_STRING: /`(\\(?:[\s\S])|(?:(?!(\\|`|\r|\n))[\s\S]*?)|\r?\n)*`/,
    INT: /-?[0-9]+/,
    WS: /\s+/,
    ML_COMMENT: /\/\*[\s\S]*?\*\//,
    SL_COMMENT: /\/\/[^\n\r]*/,
};

export type AgentlangTerminalNames = keyof typeof AgentlangTerminals;

export type AgentlangKeywordNames =
    | "!="
    | "("
    | ")"
    | "*"
    | "+"
    | ","
    | "-"
    | "-->"
    | "."
    | "/"
    | ":"
    | ";"
    | "<"
    | "<="
    | "<>"
    | "="
    | "=="
    | ">"
    | ">="
    | "?"
    | "@"
    | "@actions"
    | "@after"
    | "@as"
    | "@asc"
    | "@async"
    | "@before"
    | "@catch"
    | "@desc"
    | "@distinct"
    | "@enum"
    | "@expr"
    | "@from"
    | "@full_join"
    | "@groupBy"
    | "@inner_join"
    | "@into"
    | "@join"
    | "@left_join"
    | "@meta"
    | "@oneof"
    | "@orderBy"
    | "@public"
    | "@rbac"
    | "@ref"
    | "@right_join"
    | "@then"
    | "@upsert"
    | "@where"
    | "@withRole"
    | "@with_unique"
    | "["
    | "]"
    | "agent"
    | "agentlang/retry"
    | "allow"
    | "and"
    | "attempts"
    | "await"
    | "backoff"
    | "between"
    | "case"
    | "commitTransaction"
    | "contains"
    | "create"
    | "decision"
    | "delete"
    | "directive"
    | "else"
    | "entity"
    | "error"
    | "eval"
    | "event"
    | "extends"
    | "false"
    | "flow"
    | "for"
    | "glossaryEntry"
    | "if"
    | "import"
    | "in"
    | "like"
    | "module"
    | "not"
    | "not_found"
    | "onSubscription"
    | "or"
    | "purge"
    | "query"
    | "read"
    | "record"
    | "relationship"
    | "resolver"
    | "return"
    | "roles"
    | "rollbackTransaction"
    | "scenario"
    | "startTransaction"
    | "subscribe"
    | "throw"
    | "true"
    | "update"
    | "upsert"
    | "where"
    | "workflow"
    | "{"
    | "}";

export type AgentlangTokenNames = AgentlangTerminalNames | AgentlangKeywordNames;

export interface ActionEntry extends langium.AstNode {
    readonly $container: EntityActionsDefinitions;
    readonly $type: 'ActionEntry';
    event: string;
    name: string;
}

export const ActionEntry = {
    $type: 'ActionEntry',
    event: 'event',
    name: 'name'
} as const;

export function isActionEntry(item: unknown): item is ActionEntry {
    return reflection.isInstance(item, ActionEntry.$type);
}

export interface AfterTriggerDefinition extends langium.AstNode {
    readonly $container: PrePostTriggerDefinition;
    readonly $type: 'AfterTriggerDefinition';
    triggers: TriggerDefinition;
}

export const AfterTriggerDefinition = {
    $type: 'AfterTriggerDefinition',
    triggers: 'triggers'
} as const;

export function isAfterTriggerDefinition(item: unknown): item is AfterTriggerDefinition {
    return reflection.isInstance(item, AfterTriggerDefinition.$type);
}

export interface AgentDefinition extends langium.AstNode {
    readonly $container: ModuleDefinition | PublicAgentDefinition;
    readonly $type: 'AgentDefinition';
    body?: GenericDefBody;
    name: GenericName;
}

export const AgentDefinition = {
    $type: 'AgentDefinition',
    body: 'body',
    name: 'name'
} as const;

export function isAgentDefinition(item: unknown): item is AgentDefinition {
    return reflection.isInstance(item, AgentDefinition.$type);
}

export interface AgentEvaluatorDefinition extends langium.AstNode {
    readonly $container: ModuleDefinition;
    readonly $type: 'AgentEvaluatorDefinition';
    attributes: Array<SetAttribute>;
    name?: string;
}

export const AgentEvaluatorDefinition = {
    $type: 'AgentEvaluatorDefinition',
    attributes: 'attributes',
    name: 'name'
} as const;

export function isAgentEvaluatorDefinition(item: unknown): item is AgentEvaluatorDefinition {
    return reflection.isInstance(item, AgentEvaluatorDefinition.$type);
}

export interface AgentXtraAttribute extends langium.AstNode {
    readonly $container: AgentXtraSpec;
    readonly $type: 'AgentXtraAttribute' | 'Ref';
    name: string;
    value: STRING;
}

export const AgentXtraAttribute = {
    $type: 'AgentXtraAttribute',
    name: 'name',
    value: 'value'
} as const;

export function isAgentXtraAttribute(item: unknown): item is AgentXtraAttribute {
    return reflection.isInstance(item, AgentXtraAttribute.$type);
}

export interface AgentXtraSpec extends langium.AstNode {
    readonly $container: GlossaryEntryDefinition;
    readonly $type: 'AgentXtraSpec';
    attributes: Array<AgentXtraAttribute>;
}

export const AgentXtraSpec = {
    $type: 'AgentXtraSpec',
    attributes: 'attributes'
} as const;

export function isAgentXtraSpec(item: unknown): item is AgentXtraSpec {
    return reflection.isInstance(item, AgentXtraSpec.$type);
}

export interface AggregateFunctionSpec extends langium.AstNode {
    readonly $container: SelectIntoEntry | SetAttribute;
    readonly $type: 'AggregateFunctionSpec';
    args: Array<QualifiedName>;
    name: string;
}

export const AggregateFunctionSpec = {
    $type: 'AggregateFunctionSpec',
    args: 'args',
    name: 'name'
} as const;

export function isAggregateFunctionSpec(item: unknown): item is AggregateFunctionSpec {
    return reflection.isInstance(item, AggregateFunctionSpec.$type);
}

export interface AliasSpec extends langium.AstNode {
    readonly $container: RuntimeHint;
    readonly $type: 'AliasSpec';
    alias?: string;
    aliases: Array<string>;
}

export const AliasSpec = {
    $type: 'AliasSpec',
    alias: 'alias',
    aliases: 'aliases'
} as const;

export function isAliasSpec(item: unknown): item is AliasSpec {
    return reflection.isInstance(item, AliasSpec.$type);
}

export interface ArrayLiteral extends langium.AstNode {
    readonly $container: Literal;
    readonly $type: 'ArrayLiteral';
    vals: Array<Statement>;
}

export const ArrayLiteral = {
    $type: 'ArrayLiteral',
    vals: 'vals'
} as const;

export function isArrayLiteral(item: unknown): item is ArrayLiteral {
    return reflection.isInstance(item, ArrayLiteral.$type);
}

export interface AsyncFnCall extends langium.AstNode {
    readonly $container: Literal;
    readonly $type: 'AsyncFnCall';
    fnCall: FnCall;
}

export const AsyncFnCall = {
    $type: 'AsyncFnCall',
    fnCall: 'fnCall'
} as const;

export function isAsyncFnCall(item: unknown): item is AsyncFnCall {
    return reflection.isInstance(item, AsyncFnCall.$type);
}

export interface AttributeDefinition extends langium.AstNode {
    readonly $container: RecordSchemaDefinition;
    readonly $type: 'AttributeDefinition';
    arrayType?: QualifiedName;
    enumSpec?: EnumSpec;
    expr?: Expr;
    name: string;
    oneOfSpec?: OneOfSpec;
    properties: Array<PropertyDefinition>;
    refSpec?: RefSpec;
    type?: QualifiedName;
}

export const AttributeDefinition = {
    $type: 'AttributeDefinition',
    arrayType: 'arrayType',
    enumSpec: 'enumSpec',
    expr: 'expr',
    name: 'name',
    oneOfSpec: 'oneOfSpec',
    properties: 'properties',
    refSpec: 'refSpec',
    type: 'type'
} as const;

export function isAttributeDefinition(item: unknown): item is AttributeDefinition {
    return reflection.isInstance(item, AttributeDefinition.$type);
}

export type AttributeValueExpression = Expr;

export const AttributeValueExpression = {
    $type: 'AttributeValueExpression'
} as const;

export function isAttributeValueExpression(item: unknown): item is AttributeValueExpression {
    return reflection.isInstance(item, AttributeValueExpression.$type);
}

export interface BackoffSpec extends langium.AstNode {
    readonly $container: RetryDefinition;
    readonly $type: 'BackoffSpec';
    attributes: Array<SetAttribute>;
}

export const BackoffSpec = {
    $type: 'BackoffSpec',
    attributes: 'attributes'
} as const;

export function isBackoffSpec(item: unknown): item is BackoffSpec {
    return reflection.isInstance(item, BackoffSpec.$type);
}

export interface BeforeTriggerDefinition extends langium.AstNode {
    readonly $container: PrePostTriggerDefinition;
    readonly $type: 'BeforeTriggerDefinition';
    triggers: TriggerDefinition;
}

export const BeforeTriggerDefinition = {
    $type: 'BeforeTriggerDefinition',
    triggers: 'triggers'
} as const;

export function isBeforeTriggerDefinition(item: unknown): item is BeforeTriggerDefinition {
    return reflection.isInstance(item, BeforeTriggerDefinition.$type);
}

export interface BinExpr extends langium.AstNode {
    readonly $container: AttributeDefinition | BinExpr | CaseEntry | FnCall | Group | If | MapEntry | NegExpr | NotExpr | Pattern | SetAttribute | ThrowError | WhereSpecClause;
    readonly $type: 'BinExpr';
    e1: Expr | PrimExpr;
    e2: Expr | PrimExpr;
    op: '!=' | '*' | '+' | '-' | '/' | '<' | '<=' | '<>' | '==' | '>' | '>=' | 'and' | 'in' | 'like' | 'or';
}

export const BinExpr = {
    $type: 'BinExpr',
    e1: 'e1',
    e2: 'e2',
    op: 'op'
} as const;

export function isBinExpr(item: unknown): item is BinExpr {
    return reflection.isInstance(item, BinExpr.$type);
}

export type Boolean = 'false' | 'true';

export function isBoolean(item: unknown): item is Boolean {
    return item === 'true' || item === 'false';
}

export interface CaseEntry extends langium.AstNode {
    readonly $container: DecisionDefBody;
    readonly $type: 'CaseEntry';
    cond: Expr;
    statements: Array<Statement>;
}

export const CaseEntry = {
    $type: 'CaseEntry',
    cond: 'cond',
    statements: 'statements'
} as const;

export function isCaseEntry(item: unknown): item is CaseEntry {
    return reflection.isInstance(item, CaseEntry.$type);
}

export interface CatchSpec extends langium.AstNode {
    readonly $container: RuntimeHint;
    readonly $type: 'CatchSpec';
    handlers: Array<Handler>;
}

export const CatchSpec = {
    $type: 'CatchSpec',
    handlers: 'handlers'
} as const;

export function isCatchSpec(item: unknown): item is CatchSpec {
    return reflection.isInstance(item, CatchSpec.$type);
}

export interface CompositeUniqueDefinition extends langium.AstNode {
    readonly $container: RecordExtraDefinition;
    readonly $type: 'CompositeUniqueDefinition';
    attrs: Array<string>;
}

export const CompositeUniqueDefinition = {
    $type: 'CompositeUniqueDefinition',
    attrs: 'attrs'
} as const;

export function isCompositeUniqueDefinition(item: unknown): item is CompositeUniqueDefinition {
    return reflection.isInstance(item, CompositeUniqueDefinition.$type);
}

export interface ConditionalFlowStep extends langium.AstNode {
    readonly $container: FlowEntry;
    readonly $type: 'ConditionalFlowStep';
    expr: STRING;
    next: FlowStepSpec;
}

export const ConditionalFlowStep = {
    $type: 'ConditionalFlowStep',
    expr: 'expr',
    next: 'next'
} as const;

export function isConditionalFlowStep(item: unknown): item is ConditionalFlowStep {
    return reflection.isInstance(item, ConditionalFlowStep.$type);
}

export interface CrudMap extends langium.AstNode {
    readonly $container: Pattern;
    readonly $type: 'CrudMap';
    body?: CrudMapBody;
    name: QualifiedName | QueryId;
    queryOptions: Array<QueryOption>;
    relationships: Array<RelationshipPattern>;
    source?: Literal;
}

export const CrudMap = {
    $type: 'CrudMap',
    body: 'body',
    name: 'name',
    queryOptions: 'queryOptions',
    relationships: 'relationships',
    source: 'source'
} as const;

export function isCrudMap(item: unknown): item is CrudMap {
    return reflection.isInstance(item, CrudMap.$type);
}

export interface CrudMapBody extends langium.AstNode {
    readonly $container: CrudMap;
    readonly $type: 'CrudMapBody';
    attributes: Array<SetAttribute>;
    properties: Array<PropertyDefinition>;
}

export const CrudMapBody = {
    $type: 'CrudMapBody',
    attributes: 'attributes',
    properties: 'properties'
} as const;

export function isCrudMapBody(item: unknown): item is CrudMapBody {
    return reflection.isInstance(item, CrudMapBody.$type);
}

export type Decimal = number;

export function isDecimal(item: unknown): item is Decimal {
    return typeof item === 'number';
}

export interface DecisionDefBody extends langium.AstNode {
    readonly $container: DecisionDefinition;
    readonly $type: 'DecisionDefBody';
    cases: Array<CaseEntry>;
}

export const DecisionDefBody = {
    $type: 'DecisionDefBody',
    cases: 'cases'
} as const;

export function isDecisionDefBody(item: unknown): item is DecisionDefBody {
    return reflection.isInstance(item, DecisionDefBody.$type);
}

export interface DecisionDefinition extends langium.AstNode {
    readonly $container: ModuleDefinition;
    readonly $type: 'DecisionDefinition';
    body?: DecisionDefBody;
    name: GenericName;
}

export const DecisionDefinition = {
    $type: 'DecisionDefinition',
    body: 'body',
    name: 'name'
} as const;

export function isDecisionDefinition(item: unknown): item is DecisionDefinition {
    return reflection.isInstance(item, DecisionDefinition.$type);
}

export type Definition = AgentDefinition | AgentEvaluatorDefinition | DecisionDefinition | DirectiveDefinition | FlowDefinition | GlossaryEntryDefinition | PublicAgentDefinition | PublicWorkflowDefinition | RelationshipDefinition | ResolverDefinition | RetryDefinition | ScenarioDefinition | SchemaDefinition | StandaloneStatement | WorkflowDefinition;

export const Definition = {
    $type: 'Definition'
} as const;

export function isDefinition(item: unknown): item is Definition {
    return reflection.isInstance(item, Definition.$type);
}

export interface Delete extends langium.AstNode {
    readonly $container: Pattern;
    readonly $type: 'Delete';
    pattern: Pattern;
}

export const Delete = {
    $type: 'Delete',
    pattern: 'pattern'
} as const;

export function isDelete(item: unknown): item is Delete {
    return reflection.isInstance(item, Delete.$type);
}

export interface DirectiveDefinition extends langium.AstNode {
    readonly $container: ModuleDefinition;
    readonly $type: 'DirectiveDefinition';
    body?: MapLiteral;
    dir?: If;
    name: Ref;
}

export const DirectiveDefinition = {
    $type: 'DirectiveDefinition',
    body: 'body',
    dir: 'dir',
    name: 'name'
} as const;

export function isDirectiveDefinition(item: unknown): item is DirectiveDefinition {
    return reflection.isInstance(item, DirectiveDefinition.$type);
}

export interface Else extends langium.AstNode {
    readonly $container: If;
    readonly $type: 'Else';
    statements: Array<Statement>;
}

export const Else = {
    $type: 'Else',
    statements: 'statements'
} as const;

export function isElse(item: unknown): item is Else {
    return reflection.isInstance(item, Else.$type);
}

export interface EntityActionsDefinitions extends langium.AstNode {
    readonly $container: RecordExtraDefinition;
    readonly $type: 'EntityActionsDefinitions';
    entries: Array<ActionEntry>;
}

export const EntityActionsDefinitions = {
    $type: 'EntityActionsDefinitions',
    entries: 'entries'
} as const;

export function isEntityActionsDefinitions(item: unknown): item is EntityActionsDefinitions {
    return reflection.isInstance(item, EntityActionsDefinitions.$type);
}

export interface EntityDefinition extends langium.AstNode {
    readonly $container: ModuleDefinition;
    readonly $type: 'EntityDefinition';
    extends?: ExtendsClause;
    name: QualifiedName;
    schema: RecordSchemaDefinition;
}

export const EntityDefinition = {
    $type: 'EntityDefinition',
    extends: 'extends',
    name: 'name',
    schema: 'schema'
} as const;

export function isEntityDefinition(item: unknown): item is EntityDefinition {
    return reflection.isInstance(item, EntityDefinition.$type);
}

export interface EnumSpec extends langium.AstNode {
    readonly $container: AttributeDefinition;
    readonly $type: 'EnumSpec';
    type?: QualifiedName;
    values: Array<STRING>;
}

export const EnumSpec = {
    $type: 'EnumSpec',
    type: 'type',
    values: 'values'
} as const;

export function isEnumSpec(item: unknown): item is EnumSpec {
    return reflection.isInstance(item, EnumSpec.$type);
}

export interface EventDefinition extends langium.AstNode {
    readonly $container: ModuleDefinition | PublicEventDefinition;
    readonly $type: 'EventDefinition';
    extends?: ExtendsClause;
    name: QualifiedName;
    schema: RecordSchemaDefinition;
}

export const EventDefinition = {
    $type: 'EventDefinition',
    extends: 'extends',
    name: 'name',
    schema: 'schema'
} as const;

export function isEventDefinition(item: unknown): item is EventDefinition {
    return reflection.isInstance(item, EventDefinition.$type);
}

export type Expr = BinExpr | PrimExpr;

export const Expr = {
    $type: 'Expr'
} as const;

export function isExpr(item: unknown): item is Expr {
    return reflection.isInstance(item, Expr.$type);
}

export interface ExtendsClause extends langium.AstNode {
    readonly $container: EntityDefinition | EventDefinition | RecordDefinition;
    readonly $type: 'ExtendsClause';
    parentName: QualifiedName;
}

export const ExtendsClause = {
    $type: 'ExtendsClause',
    parentName: 'parentName'
} as const;

export function isExtendsClause(item: unknown): item is ExtendsClause {
    return reflection.isInstance(item, ExtendsClause.$type);
}

export interface FlowDefBody extends langium.AstNode {
    readonly $container: FlowDefinition;
    readonly $type: 'FlowDefBody';
    entries: Array<FlowEntry>;
}

export const FlowDefBody = {
    $type: 'FlowDefBody',
    entries: 'entries'
} as const;

export function isFlowDefBody(item: unknown): item is FlowDefBody {
    return reflection.isInstance(item, FlowDefBody.$type);
}

export interface FlowDefinition extends langium.AstNode {
    readonly $container: ModuleDefinition;
    readonly $type: 'FlowDefinition';
    body?: FlowDefBody;
    name: GenericName;
}

export const FlowDefinition = {
    $type: 'FlowDefinition',
    body: 'body',
    name: 'name'
} as const;

export function isFlowDefinition(item: unknown): item is FlowDefinition {
    return reflection.isInstance(item, FlowDefinition.$type);
}

export interface FlowEntry extends langium.AstNode {
    readonly $container: FlowDefBody;
    readonly $type: 'FlowEntry';
    cond?: ConditionalFlowStep;
    next?: FlowStepSpec;
    root: QueryId;
}

export const FlowEntry = {
    $type: 'FlowEntry',
    cond: 'cond',
    next: 'next',
    root: 'root'
} as const;

export function isFlowEntry(item: unknown): item is FlowEntry {
    return reflection.isInstance(item, FlowEntry.$type);
}

export type FlowStepSpec = Statement;

export const FlowStepSpec = {
    $type: 'FlowStepSpec'
} as const;

export function isFlowStepSpec(item: unknown): item is FlowStepSpec {
    return reflection.isInstance(item, FlowStepSpec.$type);
}

export interface FnCall extends langium.AstNode {
    readonly $container: AsyncFnCall | Literal;
    readonly $type: 'FnCall';
    args: Array<Expr>;
    name: Ref | string;
}

export const FnCall = {
    $type: 'FnCall',
    args: 'args',
    name: 'name'
} as const;

export function isFnCall(item: unknown): item is FnCall {
    return reflection.isInstance(item, FnCall.$type);
}

export interface ForEach extends langium.AstNode {
    readonly $container: Pattern;
    readonly $type: 'ForEach';
    src: Pattern;
    statements: Array<Statement>;
    var: string;
}

export const ForEach = {
    $type: 'ForEach',
    src: 'src',
    statements: 'statements',
    var: 'var'
} as const;

export function isForEach(item: unknown): item is ForEach {
    return reflection.isInstance(item, ForEach.$type);
}

export interface FullTextSearch extends langium.AstNode {
    readonly $container: Pattern;
    readonly $type: 'FullTextSearch';
    name: QueryId;
    options?: MapLiteral;
    query: Literal;
}

export const FullTextSearch = {
    $type: 'FullTextSearch',
    name: 'name',
    options: 'options',
    query: 'query'
} as const;

export function isFullTextSearch(item: unknown): item is FullTextSearch {
    return reflection.isInstance(item, FullTextSearch.$type);
}

export interface GenericDefBody extends langium.AstNode {
    readonly $container: AgentDefinition;
    readonly $type: 'GenericDefBody';
    attributes: Array<GenericPropertyDef>;
}

export const GenericDefBody = {
    $type: 'GenericDefBody',
    attributes: 'attributes'
} as const;

export function isGenericDefBody(item: unknown): item is GenericDefBody {
    return reflection.isInstance(item, GenericDefBody.$type);
}

export type GenericName = STRING | string;

export function isGenericName(item: unknown): item is GenericName {
    return isSTRING(item) || (typeof item === 'string' && (/(?:[_a-zA-Z][\w_]*)(\/(?:[_a-zA-Z][\w_]*))?/.test(item)));
}

export interface GenericPropertyDef extends langium.AstNode {
    readonly $container: GenericDefBody;
    readonly $type: 'GenericPropertyDef';
    name: string;
    value: Literal;
}

export const GenericPropertyDef = {
    $type: 'GenericPropertyDef',
    name: 'name',
    value: 'value'
} as const;

export function isGenericPropertyDef(item: unknown): item is GenericPropertyDef {
    return reflection.isInstance(item, GenericPropertyDef.$type);
}

export interface GlossaryEntryDefinition extends langium.AstNode {
    readonly $container: ModuleDefinition;
    readonly $type: 'GlossaryEntryDefinition';
    body?: MapLiteral;
    glos?: AgentXtraSpec;
    name: Ref;
}

export const GlossaryEntryDefinition = {
    $type: 'GlossaryEntryDefinition',
    body: 'body',
    glos: 'glos',
    name: 'name'
} as const;

export function isGlossaryEntryDefinition(item: unknown): item is GlossaryEntryDefinition {
    return reflection.isInstance(item, GlossaryEntryDefinition.$type);
}

export interface Group extends langium.AstNode {
    readonly $container: AttributeDefinition | BinExpr | CaseEntry | FnCall | Group | If | MapEntry | NegExpr | NotExpr | Pattern | SetAttribute | ThrowError | WhereSpecClause;
    readonly $type: 'Group';
    ge: Expr;
}

export const Group = {
    $type: 'Group',
    ge: 'ge'
} as const;

export function isGroup(item: unknown): item is Group {
    return reflection.isInstance(item, Group.$type);
}

export interface GroupByClause extends langium.AstNode {
    readonly $container: QueryOption;
    readonly $type: 'GroupByClause';
    colNames: Array<QualifiedName>;
}

export const GroupByClause = {
    $type: 'GroupByClause',
    colNames: 'colNames'
} as const;

export function isGroupByClause(item: unknown): item is GroupByClause {
    return reflection.isInstance(item, GroupByClause.$type);
}

export interface Handler extends langium.AstNode {
    readonly $container: CatchSpec;
    readonly $type: 'Handler';
    except: 'error' | 'not_found';
    stmt: Statement;
}

export const Handler = {
    $type: 'Handler',
    except: 'except',
    stmt: 'stmt'
} as const;

export function isHandler(item: unknown): item is Handler {
    return reflection.isInstance(item, Handler.$type);
}

export interface If extends langium.AstNode {
    readonly $container: DirectiveDefinition | IfWithAlias | Pattern | ScenarioDefinition;
    readonly $type: 'If';
    cond: Expr;
    else?: Else;
    statements: Array<Statement>;
}

export const If = {
    $type: 'If',
    cond: 'cond',
    else: 'else',
    statements: 'statements'
} as const;

export function isIf(item: unknown): item is If {
    return reflection.isInstance(item, If.$type);
}

export interface IfWithAlias extends langium.AstNode {
    readonly $container: Pattern;
    readonly $type: 'IfWithAlias';
    if: If;
}

export const IfWithAlias = {
    $type: 'IfWithAlias',
    if: 'if'
} as const;

export function isIfWithAlias(item: unknown): item is IfWithAlias {
    return reflection.isInstance(item, IfWithAlias.$type);
}

export interface Import extends langium.AstNode {
    readonly $container: ModuleDefinition;
    readonly $type: 'Import';
    name: string;
    path: STRING;
}

export const Import = {
    $type: 'Import',
    name: 'name',
    path: 'path'
} as const;

export function isImport(item: unknown): item is Import {
    return reflection.isInstance(item, Import.$type);
}

export interface JoinSpec extends langium.AstNode {
    readonly $container: QueryOption;
    readonly $type: 'JoinSpec';
    lhs: QueryId;
    name: QualifiedName;
    op?: SqlComparisonOpr;
    rhs: Ref;
    type: JoinType;
}

export const JoinSpec = {
    $type: 'JoinSpec',
    lhs: 'lhs',
    name: 'name',
    op: 'op',
    rhs: 'rhs',
    type: 'type'
} as const;

export function isJoinSpec(item: unknown): item is JoinSpec {
    return reflection.isInstance(item, JoinSpec.$type);
}

export type JoinType = '@full_join' | '@inner_join' | '@join' | '@left_join' | '@right_join';

export function isJoinType(item: unknown): item is JoinType {
    return item === '@join' || item === '@inner_join' || item === '@left_join' || item === '@right_join' || item === '@full_join';
}

export interface KvPair extends langium.AstNode {
    readonly $container: KvPairs;
    readonly $type: 'KvPair';
    key?: string;
    value: Literal;
}

export const KvPair = {
    $type: 'KvPair',
    key: 'key',
    value: 'value'
} as const;

export function isKvPair(item: unknown): item is KvPair {
    return reflection.isInstance(item, KvPair.$type);
}

export interface KvPairs extends langium.AstNode {
    readonly $container: PropertyDefinition;
    readonly $type: 'KvPairs';
    pairs: Array<KvPair>;
}

export const KvPairs = {
    $type: 'KvPairs',
    pairs: 'pairs'
} as const;

export function isKvPairs(item: unknown): item is KvPairs {
    return reflection.isInstance(item, KvPairs.$type);
}

export interface Literal extends langium.AstNode {
    readonly $container: AttributeDefinition | BinExpr | CaseEntry | CrudMap | FnCall | FullTextSearch | GenericPropertyDef | Group | If | KvPair | MapEntry | NegExpr | NotExpr | Pattern | SetAttribute | ThrowError | WhereSpecClause;
    readonly $type: 'Literal';
    array?: ArrayLiteral;
    asyncFnCall?: AsyncFnCall;
    bool?: Boolean;
    fnCall?: FnCall;
    id?: string;
    map?: MapLiteral;
    num?: Decimal;
    ref?: Ref;
    str?: STRING;
}

export const Literal = {
    $type: 'Literal',
    array: 'array',
    asyncFnCall: 'asyncFnCall',
    bool: 'bool',
    fnCall: 'fnCall',
    id: 'id',
    map: 'map',
    num: 'num',
    ref: 'ref',
    str: 'str'
} as const;

export function isLiteral(item: unknown): item is Literal {
    return reflection.isInstance(item, Literal.$type);
}

export interface MapEntry extends langium.AstNode {
    readonly $container: MapLiteral;
    readonly $type: 'MapEntry';
    key: MapKey;
    value: Expr;
}

export const MapEntry = {
    $type: 'MapEntry',
    key: 'key',
    value: 'value'
} as const;

export function isMapEntry(item: unknown): item is MapEntry {
    return reflection.isInstance(item, MapEntry.$type);
}

export interface MapKey extends langium.AstNode {
    readonly $container: MapEntry;
    readonly $type: 'MapKey';
    bool?: Boolean;
    num?: Decimal;
    str?: STRING;
}

export const MapKey = {
    $type: 'MapKey',
    bool: 'bool',
    num: 'num',
    str: 'str'
} as const;

export function isMapKey(item: unknown): item is MapKey {
    return reflection.isInstance(item, MapKey.$type);
}

export interface MapLiteral extends langium.AstNode {
    readonly $container: DirectiveDefinition | FullTextSearch | GlossaryEntryDefinition | Literal | MetaDefinition | ScenarioDefinition;
    readonly $type: 'MapLiteral';
    entries: Array<MapEntry>;
}

export const MapLiteral = {
    $type: 'MapLiteral',
    entries: 'entries'
} as const;

export function isMapLiteral(item: unknown): item is MapLiteral {
    return reflection.isInstance(item, MapLiteral.$type);
}

export interface MetaDefinition extends langium.AstNode {
    readonly $container: RecordExtraDefinition;
    readonly $type: 'MetaDefinition';
    spec: MapLiteral;
}

export const MetaDefinition = {
    $type: 'MetaDefinition',
    spec: 'spec'
} as const;

export function isMetaDefinition(item: unknown): item is MetaDefinition {
    return reflection.isInstance(item, MetaDefinition.$type);
}

export interface ModuleDefinition extends langium.AstNode {
    readonly $type: 'ModuleDefinition';
    defs: Array<Definition>;
    imports: Array<Import>;
    name: QualifiedName;
}

export const ModuleDefinition = {
    $type: 'ModuleDefinition',
    defs: 'defs',
    imports: 'imports',
    name: 'name'
} as const;

export function isModuleDefinition(item: unknown): item is ModuleDefinition {
    return reflection.isInstance(item, ModuleDefinition.$type);
}

export interface NegExpr extends langium.AstNode {
    readonly $container: AttributeDefinition | BinExpr | CaseEntry | FnCall | Group | If | MapEntry | NegExpr | NotExpr | Pattern | SetAttribute | ThrowError | WhereSpecClause;
    readonly $type: 'NegExpr';
    ne: Expr;
}

export const NegExpr = {
    $type: 'NegExpr',
    ne: 'ne'
} as const;

export function isNegExpr(item: unknown): item is NegExpr {
    return reflection.isInstance(item, NegExpr.$type);
}

export interface NodeDefinition extends langium.AstNode {
    readonly $container: RelNodes;
    readonly $type: 'NodeDefinition';
    alias?: string;
    name: QualifiedName;
}

export const NodeDefinition = {
    $type: 'NodeDefinition',
    alias: 'alias',
    name: 'name'
} as const;

export function isNodeDefinition(item: unknown): item is NodeDefinition {
    return reflection.isInstance(item, NodeDefinition.$type);
}

export interface NotExpr extends langium.AstNode {
    readonly $container: AttributeDefinition | BinExpr | CaseEntry | FnCall | Group | If | MapEntry | NegExpr | NotExpr | Pattern | SetAttribute | ThrowError | WhereSpecClause;
    readonly $type: 'NotExpr';
    ne: Expr;
}

export const NotExpr = {
    $type: 'NotExpr',
    ne: 'ne'
} as const;

export function isNotExpr(item: unknown): item is NotExpr {
    return reflection.isInstance(item, NotExpr.$type);
}

export interface OneOfSpec extends langium.AstNode {
    readonly $container: AttributeDefinition;
    readonly $type: 'OneOfSpec';
    ref: Ref;
}

export const OneOfSpec = {
    $type: 'OneOfSpec',
    ref: 'ref'
} as const;

export function isOneOfSpec(item: unknown): item is OneOfSpec {
    return reflection.isInstance(item, OneOfSpec.$type);
}

export interface OrderByClause extends langium.AstNode {
    readonly $container: QueryOption;
    readonly $type: 'OrderByClause';
    colNames: Array<QualifiedName>;
    order?: '@asc' | '@desc';
}

export const OrderByClause = {
    $type: 'OrderByClause',
    colNames: 'colNames',
    order: 'order'
} as const;

export function isOrderByClause(item: unknown): item is OrderByClause {
    return reflection.isInstance(item, OrderByClause.$type);
}

export interface Pattern extends langium.AstNode {
    readonly $container: Delete | ForEach | Purge | RelationshipPattern | Return | Statement;
    readonly $type: 'Pattern';
    crudMap?: CrudMap;
    delete?: Delete;
    expr?: Expr;
    forEach?: ForEach;
    fullTextSearch?: FullTextSearch;
    if?: If;
    ifWithAlias?: IfWithAlias;
    purge?: Purge;
    return?: Return;
    throwError?: ThrowError;
}

export const Pattern = {
    $type: 'Pattern',
    crudMap: 'crudMap',
    delete: 'delete',
    expr: 'expr',
    forEach: 'forEach',
    fullTextSearch: 'fullTextSearch',
    if: 'if',
    ifWithAlias: 'ifWithAlias',
    purge: 'purge',
    return: 'return',
    throwError: 'throwError'
} as const;

export function isPattern(item: unknown): item is Pattern {
    return reflection.isInstance(item, Pattern.$type);
}

export interface PrePostTriggerDefinition extends langium.AstNode {
    readonly $container: RecordExtraDefinition;
    readonly $type: 'PrePostTriggerDefinition';
    after?: AfterTriggerDefinition;
    before?: BeforeTriggerDefinition;
}

export const PrePostTriggerDefinition = {
    $type: 'PrePostTriggerDefinition',
    after: 'after',
    before: 'before'
} as const;

export function isPrePostTriggerDefinition(item: unknown): item is PrePostTriggerDefinition {
    return reflection.isInstance(item, PrePostTriggerDefinition.$type);
}

export type PrimExpr = Group | Literal | NegExpr | NotExpr;

export const PrimExpr = {
    $type: 'PrimExpr'
} as const;

export function isPrimExpr(item: unknown): item is PrimExpr {
    return reflection.isInstance(item, PrimExpr.$type);
}

export interface PropertyDefinition extends langium.AstNode {
    readonly $container: AttributeDefinition | CrudMapBody | RelationshipDefinition;
    readonly $type: 'PropertyDefinition';
    name: TaggedId;
    value?: KvPairs;
}

export const PropertyDefinition = {
    $type: 'PropertyDefinition',
    name: 'name',
    value: 'value'
} as const;

export function isPropertyDefinition(item: unknown): item is PropertyDefinition {
    return reflection.isInstance(item, PropertyDefinition.$type);
}

export interface PublicAgentDefinition extends langium.AstNode {
    readonly $container: ModuleDefinition;
    readonly $type: 'PublicAgentDefinition';
    def: AgentDefinition;
}

export const PublicAgentDefinition = {
    $type: 'PublicAgentDefinition',
    def: 'def'
} as const;

export function isPublicAgentDefinition(item: unknown): item is PublicAgentDefinition {
    return reflection.isInstance(item, PublicAgentDefinition.$type);
}

export interface PublicEventDefinition extends langium.AstNode {
    readonly $container: ModuleDefinition;
    readonly $type: 'PublicEventDefinition';
    def: EventDefinition;
}

export const PublicEventDefinition = {
    $type: 'PublicEventDefinition',
    def: 'def'
} as const;

export function isPublicEventDefinition(item: unknown): item is PublicEventDefinition {
    return reflection.isInstance(item, PublicEventDefinition.$type);
}

export interface PublicWorkflowDefinition extends langium.AstNode {
    readonly $container: ModuleDefinition;
    readonly $type: 'PublicWorkflowDefinition';
    def: WorkflowDefinition;
}

export const PublicWorkflowDefinition = {
    $type: 'PublicWorkflowDefinition',
    def: 'def'
} as const;

export function isPublicWorkflowDefinition(item: unknown): item is PublicWorkflowDefinition {
    return reflection.isInstance(item, PublicWorkflowDefinition.$type);
}

export interface Purge extends langium.AstNode {
    readonly $container: Pattern;
    readonly $type: 'Purge';
    pattern: Pattern;
}

export const Purge = {
    $type: 'Purge',
    pattern: 'pattern'
} as const;

export function isPurge(item: unknown): item is Purge {
    return reflection.isInstance(item, Purge.$type);
}

export type QualifiedName = Ref | string;

export function isQualifiedName(item: unknown): item is QualifiedName {
    return isRef(item) || (typeof item === 'string' && (/(?:[_a-zA-Z][\w_]*)(\/(?:[_a-zA-Z][\w_]*))?/.test(item)));
}

export type QueryId = string;

export function isQueryId(item: unknown): item is QueryId {
    return typeof item === 'string';
}

export interface QueryOption extends langium.AstNode {
    readonly $container: CrudMap;
    readonly $type: 'QueryOption';
    distinct?: '@distinct';
    groupByClause?: GroupByClause;
    into?: SelectIntoSpec;
    join?: JoinSpec;
    orderByClause?: OrderByClause;
    upsert?: '@upsert';
    where?: WhereSpec;
}

export const QueryOption = {
    $type: 'QueryOption',
    distinct: 'distinct',
    groupByClause: 'groupByClause',
    into: 'into',
    join: 'join',
    orderByClause: 'orderByClause',
    upsert: 'upsert',
    where: 'where'
} as const;

export function isQueryOption(item: unknown): item is QueryOption {
    return reflection.isInstance(item, QueryOption.$type);
}

export interface RbacAllowSpec extends langium.AstNode {
    readonly $container: RbacSpecEntry;
    readonly $type: 'RbacAllowSpec';
    oprs: Array<RbacOpr>;
}

export const RbacAllowSpec = {
    $type: 'RbacAllowSpec',
    oprs: 'oprs'
} as const;

export function isRbacAllowSpec(item: unknown): item is RbacAllowSpec {
    return reflection.isInstance(item, RbacAllowSpec.$type);
}

export interface RbacExpressionSpec extends langium.AstNode {
    readonly $container: RbacSpecEntry;
    readonly $type: 'RbacExpressionSpec';
    lhs: Ref;
    rhs: Ref;
}

export const RbacExpressionSpec = {
    $type: 'RbacExpressionSpec',
    lhs: 'lhs',
    rhs: 'rhs'
} as const;

export function isRbacExpressionSpec(item: unknown): item is RbacExpressionSpec {
    return reflection.isInstance(item, RbacExpressionSpec.$type);
}

export interface RbacOpr extends langium.AstNode {
    readonly $container: RbacAllowSpec;
    readonly $type: 'RbacOpr';
    value: 'create' | 'delete' | 'read' | 'update';
}

export const RbacOpr = {
    $type: 'RbacOpr',
    value: 'value'
} as const;

export function isRbacOpr(item: unknown): item is RbacOpr {
    return reflection.isInstance(item, RbacOpr.$type);
}

export interface RbacRolesSpec extends langium.AstNode {
    readonly $container: RbacSpecEntry;
    readonly $type: 'RbacRolesSpec';
    roles: Array<'*' | string>;
}

export const RbacRolesSpec = {
    $type: 'RbacRolesSpec',
    roles: 'roles'
} as const;

export function isRbacRolesSpec(item: unknown): item is RbacRolesSpec {
    return reflection.isInstance(item, RbacRolesSpec.$type);
}

export interface RbacSpecDefinition extends langium.AstNode {
    readonly $container: RecordExtraDefinition;
    readonly $type: 'RbacSpecDefinition';
    specEntries: Array<RbacSpecEntries>;
}

export const RbacSpecDefinition = {
    $type: 'RbacSpecDefinition',
    specEntries: 'specEntries'
} as const;

export function isRbacSpecDefinition(item: unknown): item is RbacSpecDefinition {
    return reflection.isInstance(item, RbacSpecDefinition.$type);
}

export interface RbacSpecEntries extends langium.AstNode {
    readonly $container: RbacSpecDefinition;
    readonly $type: 'RbacSpecEntries';
    entries: Array<RbacSpecEntry>;
}

export const RbacSpecEntries = {
    $type: 'RbacSpecEntries',
    entries: 'entries'
} as const;

export function isRbacSpecEntries(item: unknown): item is RbacSpecEntries {
    return reflection.isInstance(item, RbacSpecEntries.$type);
}

export interface RbacSpecEntry extends langium.AstNode {
    readonly $container: RbacSpecEntries;
    readonly $type: 'RbacSpecEntry';
    allow?: RbacAllowSpec;
    expr?: RbacExpressionSpec;
    role?: RbacRolesSpec;
}

export const RbacSpecEntry = {
    $type: 'RbacSpecEntry',
    allow: 'allow',
    expr: 'expr',
    role: 'role'
} as const;

export function isRbacSpecEntry(item: unknown): item is RbacSpecEntry {
    return reflection.isInstance(item, RbacSpecEntry.$type);
}

export interface RecordDefinition extends langium.AstNode {
    readonly $container: ModuleDefinition;
    readonly $type: 'RecordDefinition';
    extends?: ExtendsClause;
    name: QualifiedName;
    schema: RecordSchemaDefinition;
}

export const RecordDefinition = {
    $type: 'RecordDefinition',
    extends: 'extends',
    name: 'name',
    schema: 'schema'
} as const;

export function isRecordDefinition(item: unknown): item is RecordDefinition {
    return reflection.isInstance(item, RecordDefinition.$type);
}

export interface RecordExtraDefinition extends langium.AstNode {
    readonly $container: RecordSchemaDefinition;
    readonly $type: 'RecordExtraDefinition';
    actions?: EntityActionsDefinitions;
    meta?: MetaDefinition;
    prePost?: PrePostTriggerDefinition;
    rbacSpec?: RbacSpecDefinition;
    uq?: CompositeUniqueDefinition;
}

export const RecordExtraDefinition = {
    $type: 'RecordExtraDefinition',
    actions: 'actions',
    meta: 'meta',
    prePost: 'prePost',
    rbacSpec: 'rbacSpec',
    uq: 'uq'
} as const;

export function isRecordExtraDefinition(item: unknown): item is RecordExtraDefinition {
    return reflection.isInstance(item, RecordExtraDefinition.$type);
}

export interface RecordSchemaDefinition extends langium.AstNode {
    readonly $container: EntityDefinition | EventDefinition | RecordDefinition | RelationshipDefinition;
    readonly $type: 'RecordSchemaDefinition';
    attributes: Array<AttributeDefinition>;
    extras: Array<RecordExtraDefinition>;
}

export const RecordSchemaDefinition = {
    $type: 'RecordSchemaDefinition',
    attributes: 'attributes',
    extras: 'extras'
} as const;

export function isRecordSchemaDefinition(item: unknown): item is RecordSchemaDefinition {
    return reflection.isInstance(item, RecordSchemaDefinition.$type);
}

export type Ref = string;

export function isRef(item: unknown): item is Ref {
    return typeof item === 'string';
}

export interface RefSpec extends langium.AstNode {
    readonly $container: AttributeDefinition;
    readonly $type: 'RefSpec';
    ref: QualifiedName;
    type?: QualifiedName;
}

export const RefSpec = {
    $type: 'RefSpec',
    ref: 'ref',
    type: 'type'
} as const;

export function isRefSpec(item: unknown): item is RefSpec {
    return reflection.isInstance(item, RefSpec.$type);
}

export interface RelationshipDefinition extends langium.AstNode {
    readonly $container: ModuleDefinition;
    readonly $type: 'RelationshipDefinition';
    name: QualifiedName;
    nodes: RelNodes;
    properties: Array<PropertyDefinition>;
    schema?: RecordSchemaDefinition;
    type: 'between' | 'contains';
}

export const RelationshipDefinition = {
    $type: 'RelationshipDefinition',
    name: 'name',
    nodes: 'nodes',
    properties: 'properties',
    schema: 'schema',
    type: 'type'
} as const;

export function isRelationshipDefinition(item: unknown): item is RelationshipDefinition {
    return reflection.isInstance(item, RelationshipDefinition.$type);
}

export interface RelationshipPattern extends langium.AstNode {
    readonly $container: CrudMap;
    readonly $type: 'RelationshipPattern';
    name: QualifiedName;
    pattern: Pattern;
}

export const RelationshipPattern = {
    $type: 'RelationshipPattern',
    name: 'name',
    pattern: 'pattern'
} as const;

export function isRelationshipPattern(item: unknown): item is RelationshipPattern {
    return reflection.isInstance(item, RelationshipPattern.$type);
}

export interface RelNodes extends langium.AstNode {
    readonly $container: RelationshipDefinition;
    readonly $type: 'RelNodes';
    node1: NodeDefinition;
    node2: NodeDefinition;
}

export const RelNodes = {
    $type: 'RelNodes',
    node1: 'node1',
    node2: 'node2'
} as const;

export function isRelNodes(item: unknown): item is RelNodes {
    return reflection.isInstance(item, RelNodes.$type);
}

export interface ResolverDefinition extends langium.AstNode {
    readonly $container: ModuleDefinition;
    readonly $type: 'ResolverDefinition';
    methods: Array<ResolverMethodSpec>;
    name: QualifiedName;
    paths: Array<ResolverPathEntry>;
}

export const ResolverDefinition = {
    $type: 'ResolverDefinition',
    methods: 'methods',
    name: 'name',
    paths: 'paths'
} as const;

export function isResolverDefinition(item: unknown): item is ResolverDefinition {
    return reflection.isInstance(item, ResolverDefinition.$type);
}

export interface ResolverFnName extends langium.AstNode {
    readonly $container: ResolverMethodSpec;
    readonly $type: 'ResolverFnName';
    name: Ref | STRING | string;
}

export const ResolverFnName = {
    $type: 'ResolverFnName',
    name: 'name'
} as const;

export function isResolverFnName(item: unknown): item is ResolverFnName {
    return reflection.isInstance(item, ResolverFnName.$type);
}

export interface ResolverMethodName extends langium.AstNode {
    readonly $container: ResolverMethodSpec;
    readonly $type: 'ResolverMethodName';
    name: 'commitTransaction' | 'create' | 'delete' | 'onSubscription' | 'query' | 'rollbackTransaction' | 'startTransaction' | 'subscribe' | 'update' | 'upsert';
}

export const ResolverMethodName = {
    $type: 'ResolverMethodName',
    name: 'name'
} as const;

export function isResolverMethodName(item: unknown): item is ResolverMethodName {
    return reflection.isInstance(item, ResolverMethodName.$type);
}

export interface ResolverMethodSpec extends langium.AstNode {
    readonly $container: ResolverDefinition;
    readonly $type: 'ResolverMethodSpec';
    fn: ResolverFnName;
    key: ResolverMethodName;
}

export const ResolverMethodSpec = {
    $type: 'ResolverMethodSpec',
    fn: 'fn',
    key: 'key'
} as const;

export function isResolverMethodSpec(item: unknown): item is ResolverMethodSpec {
    return reflection.isInstance(item, ResolverMethodSpec.$type);
}

export type ResolverPathEntry = GenericName | QualifiedName;

export function isResolverPathEntry(item: unknown): item is ResolverPathEntry {
    return isQualifiedName(item) || isGenericName(item);
}

export interface RetryDefinition extends langium.AstNode {
    readonly $container: ModuleDefinition;
    readonly $type: 'RetryDefinition';
    attempts?: Decimal;
    backoff?: BackoffSpec;
    name: string;
}

export const RetryDefinition = {
    $type: 'RetryDefinition',
    attempts: 'attempts',
    backoff: 'backoff',
    name: 'name'
} as const;

export function isRetryDefinition(item: unknown): item is RetryDefinition {
    return reflection.isInstance(item, RetryDefinition.$type);
}

export interface Return extends langium.AstNode {
    readonly $container: Pattern;
    readonly $type: 'Return';
    pattern: Pattern;
}

export const Return = {
    $type: 'Return',
    pattern: 'pattern'
} as const;

export function isReturn(item: unknown): item is Return {
    return reflection.isInstance(item, Return.$type);
}

export interface RuntimeHint extends langium.AstNode {
    readonly $container: Statement;
    readonly $type: 'RuntimeHint';
    aliasSpec?: AliasSpec;
    catchSpec?: CatchSpec;
    thenSpec?: ThenSpec;
}

export const RuntimeHint = {
    $type: 'RuntimeHint',
    aliasSpec: 'aliasSpec',
    catchSpec: 'catchSpec',
    thenSpec: 'thenSpec'
} as const;

export function isRuntimeHint(item: unknown): item is RuntimeHint {
    return reflection.isInstance(item, RuntimeHint.$type);
}

export interface ScenarioDefinition extends langium.AstNode {
    readonly $container: ModuleDefinition;
    readonly $type: 'ScenarioDefinition';
    body?: MapLiteral;
    name: Ref;
    scn?: If;
}

export const ScenarioDefinition = {
    $type: 'ScenarioDefinition',
    body: 'body',
    name: 'name',
    scn: 'scn'
} as const;

export function isScenarioDefinition(item: unknown): item is ScenarioDefinition {
    return reflection.isInstance(item, ScenarioDefinition.$type);
}

export type SchemaDefinition = EntityDefinition | EventDefinition | PublicEventDefinition | RecordDefinition;

export const SchemaDefinition = {
    $type: 'SchemaDefinition'
} as const;

export function isSchemaDefinition(item: unknown): item is SchemaDefinition {
    return reflection.isInstance(item, SchemaDefinition.$type);
}

export interface SelectIntoEntry extends langium.AstNode {
    readonly $container: SelectIntoSpec;
    readonly $type: 'SelectIntoEntry';
    aggregate?: AggregateFunctionSpec;
    alias: string;
    attribute?: Ref;
}

export const SelectIntoEntry = {
    $type: 'SelectIntoEntry',
    aggregate: 'aggregate',
    alias: 'alias',
    attribute: 'attribute'
} as const;

export function isSelectIntoEntry(item: unknown): item is SelectIntoEntry {
    return reflection.isInstance(item, SelectIntoEntry.$type);
}

export interface SelectIntoSpec extends langium.AstNode {
    readonly $container: QueryOption;
    readonly $type: 'SelectIntoSpec';
    entries: Array<SelectIntoEntry>;
}

export const SelectIntoSpec = {
    $type: 'SelectIntoSpec',
    entries: 'entries'
} as const;

export function isSelectIntoSpec(item: unknown): item is SelectIntoSpec {
    return reflection.isInstance(item, SelectIntoSpec.$type);
}

export interface SetAttribute extends langium.AstNode {
    readonly $container: AgentEvaluatorDefinition | BackoffSpec | CrudMapBody;
    readonly $type: 'SetAttribute';
    aggregate?: AggregateFunctionSpec;
    name: QueryId;
    op?: SqlComparisonOpr;
    value?: AttributeValueExpression;
}

export const SetAttribute = {
    $type: 'SetAttribute',
    aggregate: 'aggregate',
    name: 'name',
    op: 'op',
    value: 'value'
} as const;

export function isSetAttribute(item: unknown): item is SetAttribute {
    return reflection.isInstance(item, SetAttribute.$type);
}

export type SqlComparisonOpr = '!=' | '<' | '<=' | '<>' | '=' | '>' | '>=' | 'between' | 'in' | 'like';

export function isSqlComparisonOpr(item: unknown): item is SqlComparisonOpr {
    return item === '=' || item === '<>' || item === '!=' || item === '<' || item === '<=' || item === '>' || item === '>=' || item === 'in' || item === 'like' || item === 'between';
}

export interface StandaloneStatement extends langium.AstNode {
    readonly $container: ModuleDefinition;
    readonly $type: 'StandaloneStatement';
    stmt: Statement;
}

export const StandaloneStatement = {
    $type: 'StandaloneStatement',
    stmt: 'stmt'
} as const;

export function isStandaloneStatement(item: unknown): item is StandaloneStatement {
    return reflection.isInstance(item, StandaloneStatement.$type);
}

export interface Statement extends langium.AstNode {
    readonly $container: ArrayLiteral | CaseEntry | ConditionalFlowStep | Else | FlowEntry | ForEach | Handler | If | StandaloneStatement | ThenSpec | WorkflowDefinition;
    readonly $type: 'Statement';
    hints: Array<RuntimeHint>;
    pattern: Pattern;
}

export const Statement = {
    $type: 'Statement',
    hints: 'hints',
    pattern: 'pattern'
} as const;

export function isStatement(item: unknown): item is Statement {
    return reflection.isInstance(item, Statement.$type);
}

export type STRING = string;

export function isSTRING(item: unknown): item is STRING {
    return (typeof item === 'string' && (/"(\\(?:[\s\S])|(?:(?!(\\|"|\r|\n))[\s\S]*?)|\r?\n)*"/.test(item) || /`(\\(?:[\s\S])|(?:(?!(\\|`|\r|\n))[\s\S]*?)|\r?\n)*`/.test(item)));
}

export type TaggedId = string;

export function isTaggedId(item: unknown): item is TaggedId {
    return typeof item === 'string';
}

export interface ThenSpec extends langium.AstNode {
    readonly $container: RuntimeHint;
    readonly $type: 'ThenSpec';
    statements: Array<Statement>;
}

export const ThenSpec = {
    $type: 'ThenSpec',
    statements: 'statements'
} as const;

export function isThenSpec(item: unknown): item is ThenSpec {
    return reflection.isInstance(item, ThenSpec.$type);
}

export interface ThrowError extends langium.AstNode {
    readonly $container: Pattern;
    readonly $type: 'ThrowError';
    reason: Expr;
}

export const ThrowError = {
    $type: 'ThrowError',
    reason: 'reason'
} as const;

export function isThrowError(item: unknown): item is ThrowError {
    return reflection.isInstance(item, ThrowError.$type);
}

export interface TriggerDefinition extends langium.AstNode {
    readonly $container: AfterTriggerDefinition | BeforeTriggerDefinition;
    readonly $type: 'TriggerDefinition';
    entries: Array<TriggerEntry>;
}

export const TriggerDefinition = {
    $type: 'TriggerDefinition',
    entries: 'entries'
} as const;

export function isTriggerDefinition(item: unknown): item is TriggerDefinition {
    return reflection.isInstance(item, TriggerDefinition.$type);
}

export interface TriggerEntry extends langium.AstNode {
    readonly $container: TriggerDefinition;
    readonly $type: 'TriggerEntry';
    async?: '@async';
    event: string;
    on: 'create' | 'delete' | 'update';
}

export const TriggerEntry = {
    $type: 'TriggerEntry',
    async: 'async',
    event: 'event',
    on: 'on'
} as const;

export function isTriggerEntry(item: unknown): item is TriggerEntry {
    return reflection.isInstance(item, TriggerEntry.$type);
}

export interface WhereSpec extends langium.AstNode {
    readonly $container: QueryOption;
    readonly $type: 'WhereSpec';
    clauses: Array<WhereSpecClause>;
}

export const WhereSpec = {
    $type: 'WhereSpec',
    clauses: 'clauses'
} as const;

export function isWhereSpec(item: unknown): item is WhereSpec {
    return reflection.isInstance(item, WhereSpec.$type);
}

export interface WhereSpecClause extends langium.AstNode {
    readonly $container: WhereSpec;
    readonly $type: 'WhereSpecClause';
    lhs: QueryId;
    op?: SqlComparisonOpr;
    rhs: Expr;
}

export const WhereSpecClause = {
    $type: 'WhereSpecClause',
    lhs: 'lhs',
    op: 'op',
    rhs: 'rhs'
} as const;

export function isWhereSpecClause(item: unknown): item is WhereSpecClause {
    return reflection.isInstance(item, WhereSpecClause.$type);
}

export interface WorkflowDefinition extends langium.AstNode {
    readonly $container: ModuleDefinition | PublicWorkflowDefinition;
    readonly $type: 'WorkflowDefinition';
    directives?: WorkflowDirectives;
    header?: WorkflowHeader;
    name?: string;
    statements: Array<Statement>;
}

export const WorkflowDefinition = {
    $type: 'WorkflowDefinition',
    directives: 'directives',
    header: 'header',
    name: 'name',
    statements: 'statements'
} as const;

export function isWorkflowDefinition(item: unknown): item is WorkflowDefinition {
    return reflection.isInstance(item, WorkflowDefinition.$type);
}

export interface WorkflowDirectiveEntry extends langium.AstNode {
    readonly $container: WorkflowDirectives;
    readonly $type: 'WorkflowDirectiveEntry';
    tag: '@withRole';
    value: STRING | string;
}

export const WorkflowDirectiveEntry = {
    $type: 'WorkflowDirectiveEntry',
    tag: 'tag',
    value: 'value'
} as const;

export function isWorkflowDirectiveEntry(item: unknown): item is WorkflowDirectiveEntry {
    return reflection.isInstance(item, WorkflowDirectiveEntry.$type);
}

export interface WorkflowDirectives extends langium.AstNode {
    readonly $container: WorkflowDefinition;
    readonly $type: 'WorkflowDirectives';
    entries: Array<WorkflowDirectiveEntry>;
}

export const WorkflowDirectives = {
    $type: 'WorkflowDirectives',
    entries: 'entries'
} as const;

export function isWorkflowDirectives(item: unknown): item is WorkflowDirectives {
    return reflection.isInstance(item, WorkflowDirectives.$type);
}

export interface WorkflowHeader extends langium.AstNode {
    readonly $container: WorkflowDefinition;
    readonly $type: 'WorkflowHeader';
    name: QualifiedName;
    prefix: WorkflowHeaderPrefix;
    tag: WorkflowHeaderTag;
}

export const WorkflowHeader = {
    $type: 'WorkflowHeader',
    name: 'name',
    prefix: 'prefix',
    tag: 'tag'
} as const;

export function isWorkflowHeader(item: unknown): item is WorkflowHeader {
    return reflection.isInstance(item, WorkflowHeader.$type);
}

export type WorkflowHeaderPrefix = 'create' | 'delete' | 'update';

export function isWorkflowHeaderPrefix(item: unknown): item is WorkflowHeaderPrefix {
    return item === 'create' || item === 'update' || item === 'delete';
}

export type WorkflowHeaderTag = '@after' | '@before';

export function isWorkflowHeaderTag(item: unknown): item is WorkflowHeaderTag {
    return item === '@after' || item === '@before';
}

export type AgentlangAstType = {
    ActionEntry: ActionEntry
    AfterTriggerDefinition: AfterTriggerDefinition
    AgentDefinition: AgentDefinition
    AgentEvaluatorDefinition: AgentEvaluatorDefinition
    AgentXtraAttribute: AgentXtraAttribute
    AgentXtraSpec: AgentXtraSpec
    AggregateFunctionSpec: AggregateFunctionSpec
    AliasSpec: AliasSpec
    ArrayLiteral: ArrayLiteral
    AsyncFnCall: AsyncFnCall
    AttributeDefinition: AttributeDefinition
    AttributeValueExpression: AttributeValueExpression
    BackoffSpec: BackoffSpec
    BeforeTriggerDefinition: BeforeTriggerDefinition
    BinExpr: BinExpr
    CaseEntry: CaseEntry
    CatchSpec: CatchSpec
    CompositeUniqueDefinition: CompositeUniqueDefinition
    ConditionalFlowStep: ConditionalFlowStep
    CrudMap: CrudMap
    CrudMapBody: CrudMapBody
    DecisionDefBody: DecisionDefBody
    DecisionDefinition: DecisionDefinition
    Definition: Definition
    Delete: Delete
    DirectiveDefinition: DirectiveDefinition
    Else: Else
    EntityActionsDefinitions: EntityActionsDefinitions
    EntityDefinition: EntityDefinition
    EnumSpec: EnumSpec
    EventDefinition: EventDefinition
    Expr: Expr
    ExtendsClause: ExtendsClause
    FlowDefBody: FlowDefBody
    FlowDefinition: FlowDefinition
    FlowEntry: FlowEntry
    FlowStepSpec: FlowStepSpec
    FnCall: FnCall
    ForEach: ForEach
    FullTextSearch: FullTextSearch
    GenericDefBody: GenericDefBody
    GenericPropertyDef: GenericPropertyDef
    GlossaryEntryDefinition: GlossaryEntryDefinition
    Group: Group
    GroupByClause: GroupByClause
    Handler: Handler
    If: If
    IfWithAlias: IfWithAlias
    Import: Import
    JoinSpec: JoinSpec
    KvPair: KvPair
    KvPairs: KvPairs
    Literal: Literal
    MapEntry: MapEntry
    MapKey: MapKey
    MapLiteral: MapLiteral
    MetaDefinition: MetaDefinition
    ModuleDefinition: ModuleDefinition
    NegExpr: NegExpr
    NodeDefinition: NodeDefinition
    NotExpr: NotExpr
    OneOfSpec: OneOfSpec
    OrderByClause: OrderByClause
    Pattern: Pattern
    PrePostTriggerDefinition: PrePostTriggerDefinition
    PrimExpr: PrimExpr
    PropertyDefinition: PropertyDefinition
    PublicAgentDefinition: PublicAgentDefinition
    PublicEventDefinition: PublicEventDefinition
    PublicWorkflowDefinition: PublicWorkflowDefinition
    Purge: Purge
    QueryOption: QueryOption
    RbacAllowSpec: RbacAllowSpec
    RbacExpressionSpec: RbacExpressionSpec
    RbacOpr: RbacOpr
    RbacRolesSpec: RbacRolesSpec
    RbacSpecDefinition: RbacSpecDefinition
    RbacSpecEntries: RbacSpecEntries
    RbacSpecEntry: RbacSpecEntry
    RecordDefinition: RecordDefinition
    RecordExtraDefinition: RecordExtraDefinition
    RecordSchemaDefinition: RecordSchemaDefinition
    RefSpec: RefSpec
    RelNodes: RelNodes
    RelationshipDefinition: RelationshipDefinition
    RelationshipPattern: RelationshipPattern
    ResolverDefinition: ResolverDefinition
    ResolverFnName: ResolverFnName
    ResolverMethodName: ResolverMethodName
    ResolverMethodSpec: ResolverMethodSpec
    RetryDefinition: RetryDefinition
    Return: Return
    RuntimeHint: RuntimeHint
    ScenarioDefinition: ScenarioDefinition
    SchemaDefinition: SchemaDefinition
    SelectIntoEntry: SelectIntoEntry
    SelectIntoSpec: SelectIntoSpec
    SetAttribute: SetAttribute
    StandaloneStatement: StandaloneStatement
    Statement: Statement
    ThenSpec: ThenSpec
    ThrowError: ThrowError
    TriggerDefinition: TriggerDefinition
    TriggerEntry: TriggerEntry
    WhereSpec: WhereSpec
    WhereSpecClause: WhereSpecClause
    WorkflowDefinition: WorkflowDefinition
    WorkflowDirectiveEntry: WorkflowDirectiveEntry
    WorkflowDirectives: WorkflowDirectives
    WorkflowHeader: WorkflowHeader
}

export class AgentlangAstReflection extends langium.AbstractAstReflection {
    override readonly types = {
        ActionEntry: {
            name: ActionEntry.$type,
            properties: {
                event: {
                    name: ActionEntry.event
                },
                name: {
                    name: ActionEntry.name
                }
            },
            superTypes: []
        },
        AfterTriggerDefinition: {
            name: AfterTriggerDefinition.$type,
            properties: {
                triggers: {
                    name: AfterTriggerDefinition.triggers
                }
            },
            superTypes: []
        },
        AgentDefinition: {
            name: AgentDefinition.$type,
            properties: {
                body: {
                    name: AgentDefinition.body
                },
                name: {
                    name: AgentDefinition.name
                }
            },
            superTypes: [Definition.$type]
        },
        AgentEvaluatorDefinition: {
            name: AgentEvaluatorDefinition.$type,
            properties: {
                attributes: {
                    name: AgentEvaluatorDefinition.attributes,
                    defaultValue: []
                },
                name: {
                    name: AgentEvaluatorDefinition.name
                }
            },
            superTypes: [Definition.$type]
        },
        AgentXtraAttribute: {
            name: AgentXtraAttribute.$type,
            properties: {
                name: {
                    name: AgentXtraAttribute.name
                },
                value: {
                    name: AgentXtraAttribute.value
                }
            },
            superTypes: []
        },
        AgentXtraSpec: {
            name: AgentXtraSpec.$type,
            properties: {
                attributes: {
                    name: AgentXtraSpec.attributes,
                    defaultValue: []
                }
            },
            superTypes: []
        },
        AggregateFunctionSpec: {
            name: AggregateFunctionSpec.$type,
            properties: {
                args: {
                    name: AggregateFunctionSpec.args,
                    defaultValue: []
                },
                name: {
                    name: AggregateFunctionSpec.name
                }
            },
            superTypes: []
        },
        AliasSpec: {
            name: AliasSpec.$type,
            properties: {
                alias: {
                    name: AliasSpec.alias
                },
                aliases: {
                    name: AliasSpec.aliases,
                    defaultValue: []
                }
            },
            superTypes: []
        },
        ArrayLiteral: {
            name: ArrayLiteral.$type,
            properties: {
                vals: {
                    name: ArrayLiteral.vals,
                    defaultValue: []
                }
            },
            superTypes: []
        },
        AsyncFnCall: {
            name: AsyncFnCall.$type,
            properties: {
                fnCall: {
                    name: AsyncFnCall.fnCall
                }
            },
            superTypes: []
        },
        AttributeDefinition: {
            name: AttributeDefinition.$type,
            properties: {
                arrayType: {
                    name: AttributeDefinition.arrayType
                },
                enumSpec: {
                    name: AttributeDefinition.enumSpec
                },
                expr: {
                    name: AttributeDefinition.expr
                },
                name: {
                    name: AttributeDefinition.name
                },
                oneOfSpec: {
                    name: AttributeDefinition.oneOfSpec
                },
                properties: {
                    name: AttributeDefinition.properties,
                    defaultValue: []
                },
                refSpec: {
                    name: AttributeDefinition.refSpec
                },
                type: {
                    name: AttributeDefinition.type
                }
            },
            superTypes: []
        },
        AttributeValueExpression: {
            name: AttributeValueExpression.$type,
            properties: {
            },
            superTypes: []
        },
        BackoffSpec: {
            name: BackoffSpec.$type,
            properties: {
                attributes: {
                    name: BackoffSpec.attributes,
                    defaultValue: []
                }
            },
            superTypes: []
        },
        BeforeTriggerDefinition: {
            name: BeforeTriggerDefinition.$type,
            properties: {
                triggers: {
                    name: BeforeTriggerDefinition.triggers
                }
            },
            superTypes: []
        },
        BinExpr: {
            name: BinExpr.$type,
            properties: {
                e1: {
                    name: BinExpr.e1
                },
                e2: {
                    name: BinExpr.e2
                },
                op: {
                    name: BinExpr.op
                }
            },
            superTypes: [Expr.$type]
        },
        CaseEntry: {
            name: CaseEntry.$type,
            properties: {
                cond: {
                    name: CaseEntry.cond
                },
                statements: {
                    name: CaseEntry.statements,
                    defaultValue: []
                }
            },
            superTypes: []
        },
        CatchSpec: {
            name: CatchSpec.$type,
            properties: {
                handlers: {
                    name: CatchSpec.handlers,
                    defaultValue: []
                }
            },
            superTypes: []
        },
        CompositeUniqueDefinition: {
            name: CompositeUniqueDefinition.$type,
            properties: {
                attrs: {
                    name: CompositeUniqueDefinition.attrs,
                    defaultValue: []
                }
            },
            superTypes: []
        },
        ConditionalFlowStep: {
            name: ConditionalFlowStep.$type,
            properties: {
                expr: {
                    name: ConditionalFlowStep.expr
                },
                next: {
                    name: ConditionalFlowStep.next
                }
            },
            superTypes: []
        },
        CrudMap: {
            name: CrudMap.$type,
            properties: {
                body: {
                    name: CrudMap.body
                },
                name: {
                    name: CrudMap.name
                },
                queryOptions: {
                    name: CrudMap.queryOptions,
                    defaultValue: []
                },
                relationships: {
                    name: CrudMap.relationships,
                    defaultValue: []
                },
                source: {
                    name: CrudMap.source
                }
            },
            superTypes: []
        },
        CrudMapBody: {
            name: CrudMapBody.$type,
            properties: {
                attributes: {
                    name: CrudMapBody.attributes,
                    defaultValue: []
                },
                properties: {
                    name: CrudMapBody.properties,
                    defaultValue: []
                }
            },
            superTypes: []
        },
        DecisionDefBody: {
            name: DecisionDefBody.$type,
            properties: {
                cases: {
                    name: DecisionDefBody.cases,
                    defaultValue: []
                }
            },
            superTypes: []
        },
        DecisionDefinition: {
            name: DecisionDefinition.$type,
            properties: {
                body: {
                    name: DecisionDefinition.body
                },
                name: {
                    name: DecisionDefinition.name
                }
            },
            superTypes: [Definition.$type]
        },
        Definition: {
            name: Definition.$type,
            properties: {
            },
            superTypes: []
        },
        Delete: {
            name: Delete.$type,
            properties: {
                pattern: {
                    name: Delete.pattern
                }
            },
            superTypes: []
        },
        DirectiveDefinition: {
            name: DirectiveDefinition.$type,
            properties: {
                body: {
                    name: DirectiveDefinition.body
                },
                dir: {
                    name: DirectiveDefinition.dir
                },
                name: {
                    name: DirectiveDefinition.name
                }
            },
            superTypes: [Definition.$type]
        },
        Else: {
            name: Else.$type,
            properties: {
                statements: {
                    name: Else.statements,
                    defaultValue: []
                }
            },
            superTypes: []
        },
        EntityActionsDefinitions: {
            name: EntityActionsDefinitions.$type,
            properties: {
                entries: {
                    name: EntityActionsDefinitions.entries,
                    defaultValue: []
                }
            },
            superTypes: []
        },
        EntityDefinition: {
            name: EntityDefinition.$type,
            properties: {
                extends: {
                    name: EntityDefinition.extends
                },
                name: {
                    name: EntityDefinition.name
                },
                schema: {
                    name: EntityDefinition.schema
                }
            },
            superTypes: [SchemaDefinition.$type]
        },
        EnumSpec: {
            name: EnumSpec.$type,
            properties: {
                type: {
                    name: EnumSpec.type
                },
                values: {
                    name: EnumSpec.values,
                    defaultValue: []
                }
            },
            superTypes: []
        },
        EventDefinition: {
            name: EventDefinition.$type,
            properties: {
                extends: {
                    name: EventDefinition.extends
                },
                name: {
                    name: EventDefinition.name
                },
                schema: {
                    name: EventDefinition.schema
                }
            },
            superTypes: [SchemaDefinition.$type]
        },
        Expr: {
            name: Expr.$type,
            properties: {
            },
            superTypes: [AttributeValueExpression.$type]
        },
        ExtendsClause: {
            name: ExtendsClause.$type,
            properties: {
                parentName: {
                    name: ExtendsClause.parentName
                }
            },
            superTypes: []
        },
        FlowDefBody: {
            name: FlowDefBody.$type,
            properties: {
                entries: {
                    name: FlowDefBody.entries,
                    defaultValue: []
                }
            },
            superTypes: []
        },
        FlowDefinition: {
            name: FlowDefinition.$type,
            properties: {
                body: {
                    name: FlowDefinition.body
                },
                name: {
                    name: FlowDefinition.name
                }
            },
            superTypes: [Definition.$type]
        },
        FlowEntry: {
            name: FlowEntry.$type,
            properties: {
                cond: {
                    name: FlowEntry.cond
                },
                next: {
                    name: FlowEntry.next
                },
                root: {
                    name: FlowEntry.root
                }
            },
            superTypes: []
        },
        FlowStepSpec: {
            name: FlowStepSpec.$type,
            properties: {
            },
            superTypes: []
        },
        FnCall: {
            name: FnCall.$type,
            properties: {
                args: {
                    name: FnCall.args,
                    defaultValue: []
                },
                name: {
                    name: FnCall.name
                }
            },
            superTypes: []
        },
        ForEach: {
            name: ForEach.$type,
            properties: {
                src: {
                    name: ForEach.src
                },
                statements: {
                    name: ForEach.statements,
                    defaultValue: []
                },
                var: {
                    name: ForEach.var
                }
            },
            superTypes: []
        },
        FullTextSearch: {
            name: FullTextSearch.$type,
            properties: {
                name: {
                    name: FullTextSearch.name
                },
                options: {
                    name: FullTextSearch.options
                },
                query: {
                    name: FullTextSearch.query
                }
            },
            superTypes: []
        },
        GenericDefBody: {
            name: GenericDefBody.$type,
            properties: {
                attributes: {
                    name: GenericDefBody.attributes,
                    defaultValue: []
                }
            },
            superTypes: []
        },
        GenericPropertyDef: {
            name: GenericPropertyDef.$type,
            properties: {
                name: {
                    name: GenericPropertyDef.name
                },
                value: {
                    name: GenericPropertyDef.value
                }
            },
            superTypes: []
        },
        GlossaryEntryDefinition: {
            name: GlossaryEntryDefinition.$type,
            properties: {
                body: {
                    name: GlossaryEntryDefinition.body
                },
                glos: {
                    name: GlossaryEntryDefinition.glos
                },
                name: {
                    name: GlossaryEntryDefinition.name
                }
            },
            superTypes: [Definition.$type]
        },
        Group: {
            name: Group.$type,
            properties: {
                ge: {
                    name: Group.ge
                }
            },
            superTypes: [PrimExpr.$type]
        },
        GroupByClause: {
            name: GroupByClause.$type,
            properties: {
                colNames: {
                    name: GroupByClause.colNames,
                    defaultValue: []
                }
            },
            superTypes: []
        },
        Handler: {
            name: Handler.$type,
            properties: {
                except: {
                    name: Handler.except
                },
                stmt: {
                    name: Handler.stmt
                }
            },
            superTypes: []
        },
        If: {
            name: If.$type,
            properties: {
                cond: {
                    name: If.cond
                },
                else: {
                    name: If.else
                },
                statements: {
                    name: If.statements,
                    defaultValue: []
                }
            },
            superTypes: []
        },
        IfWithAlias: {
            name: IfWithAlias.$type,
            properties: {
                if: {
                    name: IfWithAlias.if
                }
            },
            superTypes: []
        },
        Import: {
            name: Import.$type,
            properties: {
                name: {
                    name: Import.name
                },
                path: {
                    name: Import.path
                }
            },
            superTypes: []
        },
        JoinSpec: {
            name: JoinSpec.$type,
            properties: {
                lhs: {
                    name: JoinSpec.lhs
                },
                name: {
                    name: JoinSpec.name
                },
                op: {
                    name: JoinSpec.op
                },
                rhs: {
                    name: JoinSpec.rhs
                },
                type: {
                    name: JoinSpec.type
                }
            },
            superTypes: []
        },
        KvPair: {
            name: KvPair.$type,
            properties: {
                key: {
                    name: KvPair.key
                },
                value: {
                    name: KvPair.value
                }
            },
            superTypes: []
        },
        KvPairs: {
            name: KvPairs.$type,
            properties: {
                pairs: {
                    name: KvPairs.pairs,
                    defaultValue: []
                }
            },
            superTypes: []
        },
        Literal: {
            name: Literal.$type,
            properties: {
                array: {
                    name: Literal.array
                },
                asyncFnCall: {
                    name: Literal.asyncFnCall
                },
                bool: {
                    name: Literal.bool
                },
                fnCall: {
                    name: Literal.fnCall
                },
                id: {
                    name: Literal.id
                },
                map: {
                    name: Literal.map
                },
                num: {
                    name: Literal.num
                },
                ref: {
                    name: Literal.ref
                },
                str: {
                    name: Literal.str
                }
            },
            superTypes: [PrimExpr.$type]
        },
        MapEntry: {
            name: MapEntry.$type,
            properties: {
                key: {
                    name: MapEntry.key
                },
                value: {
                    name: MapEntry.value
                }
            },
            superTypes: []
        },
        MapKey: {
            name: MapKey.$type,
            properties: {
                bool: {
                    name: MapKey.bool
                },
                num: {
                    name: MapKey.num
                },
                str: {
                    name: MapKey.str
                }
            },
            superTypes: []
        },
        MapLiteral: {
            name: MapLiteral.$type,
            properties: {
                entries: {
                    name: MapLiteral.entries,
                    defaultValue: []
                }
            },
            superTypes: []
        },
        MetaDefinition: {
            name: MetaDefinition.$type,
            properties: {
                spec: {
                    name: MetaDefinition.spec
                }
            },
            superTypes: []
        },
        ModuleDefinition: {
            name: ModuleDefinition.$type,
            properties: {
                defs: {
                    name: ModuleDefinition.defs,
                    defaultValue: []
                },
                imports: {
                    name: ModuleDefinition.imports,
                    defaultValue: []
                },
                name: {
                    name: ModuleDefinition.name
                }
            },
            superTypes: []
        },
        NegExpr: {
            name: NegExpr.$type,
            properties: {
                ne: {
                    name: NegExpr.ne
                }
            },
            superTypes: [PrimExpr.$type]
        },
        NodeDefinition: {
            name: NodeDefinition.$type,
            properties: {
                alias: {
                    name: NodeDefinition.alias
                },
                name: {
                    name: NodeDefinition.name
                }
            },
            superTypes: []
        },
        NotExpr: {
            name: NotExpr.$type,
            properties: {
                ne: {
                    name: NotExpr.ne
                }
            },
            superTypes: [PrimExpr.$type]
        },
        OneOfSpec: {
            name: OneOfSpec.$type,
            properties: {
                ref: {
                    name: OneOfSpec.ref
                }
            },
            superTypes: []
        },
        OrderByClause: {
            name: OrderByClause.$type,
            properties: {
                colNames: {
                    name: OrderByClause.colNames,
                    defaultValue: []
                },
                order: {
                    name: OrderByClause.order
                }
            },
            superTypes: []
        },
        Pattern: {
            name: Pattern.$type,
            properties: {
                crudMap: {
                    name: Pattern.crudMap
                },
                delete: {
                    name: Pattern.delete
                },
                expr: {
                    name: Pattern.expr
                },
                forEach: {
                    name: Pattern.forEach
                },
                fullTextSearch: {
                    name: Pattern.fullTextSearch
                },
                if: {
                    name: Pattern.if
                },
                ifWithAlias: {
                    name: Pattern.ifWithAlias
                },
                purge: {
                    name: Pattern.purge
                },
                return: {
                    name: Pattern.return
                },
                throwError: {
                    name: Pattern.throwError
                }
            },
            superTypes: []
        },
        PrePostTriggerDefinition: {
            name: PrePostTriggerDefinition.$type,
            properties: {
                after: {
                    name: PrePostTriggerDefinition.after
                },
                before: {
                    name: PrePostTriggerDefinition.before
                }
            },
            superTypes: []
        },
        PrimExpr: {
            name: PrimExpr.$type,
            properties: {
            },
            superTypes: [Expr.$type]
        },
        PropertyDefinition: {
            name: PropertyDefinition.$type,
            properties: {
                name: {
                    name: PropertyDefinition.name
                },
                value: {
                    name: PropertyDefinition.value
                }
            },
            superTypes: []
        },
        PublicAgentDefinition: {
            name: PublicAgentDefinition.$type,
            properties: {
                def: {
                    name: PublicAgentDefinition.def
                }
            },
            superTypes: [Definition.$type]
        },
        PublicEventDefinition: {
            name: PublicEventDefinition.$type,
            properties: {
                def: {
                    name: PublicEventDefinition.def
                }
            },
            superTypes: [SchemaDefinition.$type]
        },
        PublicWorkflowDefinition: {
            name: PublicWorkflowDefinition.$type,
            properties: {
                def: {
                    name: PublicWorkflowDefinition.def
                }
            },
            superTypes: [Definition.$type]
        },
        Purge: {
            name: Purge.$type,
            properties: {
                pattern: {
                    name: Purge.pattern
                }
            },
            superTypes: []
        },
        QueryOption: {
            name: QueryOption.$type,
            properties: {
                distinct: {
                    name: QueryOption.distinct
                },
                groupByClause: {
                    name: QueryOption.groupByClause
                },
                into: {
                    name: QueryOption.into
                },
                join: {
                    name: QueryOption.join
                },
                orderByClause: {
                    name: QueryOption.orderByClause
                },
                upsert: {
                    name: QueryOption.upsert
                },
                where: {
                    name: QueryOption.where
                }
            },
            superTypes: []
        },
        RbacAllowSpec: {
            name: RbacAllowSpec.$type,
            properties: {
                oprs: {
                    name: RbacAllowSpec.oprs,
                    defaultValue: []
                }
            },
            superTypes: []
        },
        RbacExpressionSpec: {
            name: RbacExpressionSpec.$type,
            properties: {
                lhs: {
                    name: RbacExpressionSpec.lhs
                },
                rhs: {
                    name: RbacExpressionSpec.rhs
                }
            },
            superTypes: []
        },
        RbacOpr: {
            name: RbacOpr.$type,
            properties: {
                value: {
                    name: RbacOpr.value
                }
            },
            superTypes: []
        },
        RbacRolesSpec: {
            name: RbacRolesSpec.$type,
            properties: {
                roles: {
                    name: RbacRolesSpec.roles,
                    defaultValue: []
                }
            },
            superTypes: []
        },
        RbacSpecDefinition: {
            name: RbacSpecDefinition.$type,
            properties: {
                specEntries: {
                    name: RbacSpecDefinition.specEntries,
                    defaultValue: []
                }
            },
            superTypes: []
        },
        RbacSpecEntries: {
            name: RbacSpecEntries.$type,
            properties: {
                entries: {
                    name: RbacSpecEntries.entries,
                    defaultValue: []
                }
            },
            superTypes: []
        },
        RbacSpecEntry: {
            name: RbacSpecEntry.$type,
            properties: {
                allow: {
                    name: RbacSpecEntry.allow
                },
                expr: {
                    name: RbacSpecEntry.expr
                },
                role: {
                    name: RbacSpecEntry.role
                }
            },
            superTypes: []
        },
        RecordDefinition: {
            name: RecordDefinition.$type,
            properties: {
                extends: {
                    name: RecordDefinition.extends
                },
                name: {
                    name: RecordDefinition.name
                },
                schema: {
                    name: RecordDefinition.schema
                }
            },
            superTypes: [SchemaDefinition.$type]
        },
        RecordExtraDefinition: {
            name: RecordExtraDefinition.$type,
            properties: {
                actions: {
                    name: RecordExtraDefinition.actions
                },
                meta: {
                    name: RecordExtraDefinition.meta
                },
                prePost: {
                    name: RecordExtraDefinition.prePost
                },
                rbacSpec: {
                    name: RecordExtraDefinition.rbacSpec
                },
                uq: {
                    name: RecordExtraDefinition.uq
                }
            },
            superTypes: []
        },
        RecordSchemaDefinition: {
            name: RecordSchemaDefinition.$type,
            properties: {
                attributes: {
                    name: RecordSchemaDefinition.attributes,
                    defaultValue: []
                },
                extras: {
                    name: RecordSchemaDefinition.extras,
                    defaultValue: []
                }
            },
            superTypes: []
        },
        RefSpec: {
            name: RefSpec.$type,
            properties: {
                ref: {
                    name: RefSpec.ref
                },
                type: {
                    name: RefSpec.type
                }
            },
            superTypes: []
        },
        RelNodes: {
            name: RelNodes.$type,
            properties: {
                node1: {
                    name: RelNodes.node1
                },
                node2: {
                    name: RelNodes.node2
                }
            },
            superTypes: []
        },
        RelationshipDefinition: {
            name: RelationshipDefinition.$type,
            properties: {
                name: {
                    name: RelationshipDefinition.name
                },
                nodes: {
                    name: RelationshipDefinition.nodes
                },
                properties: {
                    name: RelationshipDefinition.properties,
                    defaultValue: []
                },
                schema: {
                    name: RelationshipDefinition.schema
                },
                type: {
                    name: RelationshipDefinition.type
                }
            },
            superTypes: [Definition.$type]
        },
        RelationshipPattern: {
            name: RelationshipPattern.$type,
            properties: {
                name: {
                    name: RelationshipPattern.name
                },
                pattern: {
                    name: RelationshipPattern.pattern
                }
            },
            superTypes: []
        },
        ResolverDefinition: {
            name: ResolverDefinition.$type,
            properties: {
                methods: {
                    name: ResolverDefinition.methods,
                    defaultValue: []
                },
                name: {
                    name: ResolverDefinition.name
                },
                paths: {
                    name: ResolverDefinition.paths,
                    defaultValue: []
                }
            },
            superTypes: [Definition.$type]
        },
        ResolverFnName: {
            name: ResolverFnName.$type,
            properties: {
                name: {
                    name: ResolverFnName.name
                }
            },
            superTypes: []
        },
        ResolverMethodName: {
            name: ResolverMethodName.$type,
            properties: {
                name: {
                    name: ResolverMethodName.name
                }
            },
            superTypes: []
        },
        ResolverMethodSpec: {
            name: ResolverMethodSpec.$type,
            properties: {
                fn: {
                    name: ResolverMethodSpec.fn
                },
                key: {
                    name: ResolverMethodSpec.key
                }
            },
            superTypes: []
        },
        RetryDefinition: {
            name: RetryDefinition.$type,
            properties: {
                attempts: {
                    name: RetryDefinition.attempts
                },
                backoff: {
                    name: RetryDefinition.backoff
                },
                name: {
                    name: RetryDefinition.name
                }
            },
            superTypes: [Definition.$type]
        },
        Return: {
            name: Return.$type,
            properties: {
                pattern: {
                    name: Return.pattern
                }
            },
            superTypes: []
        },
        RuntimeHint: {
            name: RuntimeHint.$type,
            properties: {
                aliasSpec: {
                    name: RuntimeHint.aliasSpec
                },
                catchSpec: {
                    name: RuntimeHint.catchSpec
                },
                thenSpec: {
                    name: RuntimeHint.thenSpec
                }
            },
            superTypes: []
        },
        ScenarioDefinition: {
            name: ScenarioDefinition.$type,
            properties: {
                body: {
                    name: ScenarioDefinition.body
                },
                name: {
                    name: ScenarioDefinition.name
                },
                scn: {
                    name: ScenarioDefinition.scn
                }
            },
            superTypes: [Definition.$type]
        },
        SchemaDefinition: {
            name: SchemaDefinition.$type,
            properties: {
            },
            superTypes: [Definition.$type]
        },
        SelectIntoEntry: {
            name: SelectIntoEntry.$type,
            properties: {
                aggregate: {
                    name: SelectIntoEntry.aggregate
                },
                alias: {
                    name: SelectIntoEntry.alias
                },
                attribute: {
                    name: SelectIntoEntry.attribute
                }
            },
            superTypes: []
        },
        SelectIntoSpec: {
            name: SelectIntoSpec.$type,
            properties: {
                entries: {
                    name: SelectIntoSpec.entries,
                    defaultValue: []
                }
            },
            superTypes: []
        },
        SetAttribute: {
            name: SetAttribute.$type,
            properties: {
                aggregate: {
                    name: SetAttribute.aggregate
                },
                name: {
                    name: SetAttribute.name
                },
                op: {
                    name: SetAttribute.op
                },
                value: {
                    name: SetAttribute.value
                }
            },
            superTypes: []
        },
        StandaloneStatement: {
            name: StandaloneStatement.$type,
            properties: {
                stmt: {
                    name: StandaloneStatement.stmt
                }
            },
            superTypes: [Definition.$type]
        },
        Statement: {
            name: Statement.$type,
            properties: {
                hints: {
                    name: Statement.hints,
                    defaultValue: []
                },
                pattern: {
                    name: Statement.pattern
                }
            },
            superTypes: [FlowStepSpec.$type]
        },
        ThenSpec: {
            name: ThenSpec.$type,
            properties: {
                statements: {
                    name: ThenSpec.statements,
                    defaultValue: []
                }
            },
            superTypes: []
        },
        ThrowError: {
            name: ThrowError.$type,
            properties: {
                reason: {
                    name: ThrowError.reason
                }
            },
            superTypes: []
        },
        TriggerDefinition: {
            name: TriggerDefinition.$type,
            properties: {
                entries: {
                    name: TriggerDefinition.entries,
                    defaultValue: []
                }
            },
            superTypes: []
        },
        TriggerEntry: {
            name: TriggerEntry.$type,
            properties: {
                async: {
                    name: TriggerEntry.async
                },
                event: {
                    name: TriggerEntry.event
                },
                on: {
                    name: TriggerEntry.on
                }
            },
            superTypes: []
        },
        WhereSpec: {
            name: WhereSpec.$type,
            properties: {
                clauses: {
                    name: WhereSpec.clauses,
                    defaultValue: []
                }
            },
            superTypes: []
        },
        WhereSpecClause: {
            name: WhereSpecClause.$type,
            properties: {
                lhs: {
                    name: WhereSpecClause.lhs
                },
                op: {
                    name: WhereSpecClause.op
                },
                rhs: {
                    name: WhereSpecClause.rhs
                }
            },
            superTypes: []
        },
        WorkflowDefinition: {
            name: WorkflowDefinition.$type,
            properties: {
                directives: {
                    name: WorkflowDefinition.directives
                },
                header: {
                    name: WorkflowDefinition.header
                },
                name: {
                    name: WorkflowDefinition.name
                },
                statements: {
                    name: WorkflowDefinition.statements,
                    defaultValue: []
                }
            },
            superTypes: [Definition.$type]
        },
        WorkflowDirectiveEntry: {
            name: WorkflowDirectiveEntry.$type,
            properties: {
                tag: {
                    name: WorkflowDirectiveEntry.tag
                },
                value: {
                    name: WorkflowDirectiveEntry.value
                }
            },
            superTypes: []
        },
        WorkflowDirectives: {
            name: WorkflowDirectives.$type,
            properties: {
                entries: {
                    name: WorkflowDirectives.entries,
                    defaultValue: []
                }
            },
            superTypes: []
        },
        WorkflowHeader: {
            name: WorkflowHeader.$type,
            properties: {
                name: {
                    name: WorkflowHeader.name
                },
                prefix: {
                    name: WorkflowHeader.prefix
                },
                tag: {
                    name: WorkflowHeader.tag
                }
            },
            superTypes: []
        }
    } as const satisfies langium.AstMetaData
}

export const reflection = new AgentlangAstReflection();
