/******************************************************************************
 * This file was generated by langium-cli 3.5.0.
 * DO NOT EDIT MANUALLY!
 ******************************************************************************/

/* eslint-disable */
import * as langium from 'langium';

export const AgentlangTerminals = {
    ID: /[_a-zA-Z][\w_]*/,
    STRING: /(["'])((\\{2})*|(.*?[^\\](\\{2})*))\1/,
    INT: /-?[0-9]+/,
    WS: /\s+/,
    ML_COMMENT: /\/\*[\s\S]*?\*\//,
    SL_COMMENT: /\/\/[^\n\r]*/,
};

export type AgentlangTerminalNames = keyof typeof AgentlangTerminals;

export type AgentlangKeywordNames =
    | "("
    | ")"
    | "*"
    | "+"
    | ","
    | "-"
    | "."
    | "/"
    | ":"
    | ";"
    | "<"
    | "<="
    | "<>"
    | "="
    | ">"
    | ">="
    | "?"
    | "@"
    | "["
    | "]"
    | "and"
    | "as"
    | "between"
    | "contains"
    | "else"
    | "entity"
    | "error"
    | "event"
    | "false"
    | "for"
    | "if"
    | "import"
    | "in"
    | "like"
    | "module"
    | "not_found"
    | "or"
    | "record"
    | "relationship"
    | "throws"
    | "true"
    | "workflow"
    | "{"
    | "}";

export type AgentlangTokenNames = AgentlangTerminalNames | AgentlangKeywordNames;

export type AttributeValueExpression = Expr;

export const AttributeValueExpression = 'AttributeValueExpression';

export function isAttributeValueExpression(item: unknown): item is AttributeValueExpression {
    return reflection.isInstance(item, AttributeValueExpression);
}

export type Boolean = 'false' | 'true';

export function isBoolean(item: unknown): item is Boolean {
    return item === 'true' || item === 'false';
}

export type Decimal = number;

export function isDecimal(item: unknown): item is Decimal {
    return typeof item === 'number';
}

export type Def = Relationship | SchemaDef | Workflow;

export const Def = 'Def';

export function isDef(item: unknown): item is Def {
    return reflection.isInstance(item, Def);
}

export type Expr = BinExpr | PrimExpr;

export const Expr = 'Expr';

export function isExpr(item: unknown): item is Expr {
    return reflection.isInstance(item, Expr);
}

export type Handler = Pattern;

export const Handler = 'Handler';

export function isHandler(item: unknown): item is Handler {
    return reflection.isInstance(item, Handler);
}

export type LogicalExpression = ComparisonExpression;

export const LogicalExpression = 'LogicalExpression';

export function isLogicalExpression(item: unknown): item is LogicalExpression {
    return reflection.isInstance(item, LogicalExpression);
}

export type PrimExpr = Group | Literal | NegExpr;

export const PrimExpr = 'PrimExpr';

export function isPrimExpr(item: unknown): item is PrimExpr {
    return reflection.isInstance(item, PrimExpr);
}

export type QueryId = string;

export function isQueryId(item: unknown): item is QueryId {
    return typeof item === 'string';
}

export type RawPattern = CrudMap | ForEach | If | Literal;

export const RawPattern = 'RawPattern';

export function isRawPattern(item: unknown): item is RawPattern {
    return reflection.isInstance(item, RawPattern);
}

export type Ref = string;

export function isRef(item: unknown): item is Ref {
    return typeof item === 'string';
}

export type SchemaDef = Entity | Event | Record;

export const SchemaDef = 'SchemaDef';

export function isSchemaDef(item: unknown): item is SchemaDef {
    return reflection.isInstance(item, SchemaDef);
}

export type TaggedId = string;

export function isTaggedId(item: unknown): item is TaggedId {
    return typeof item === 'string';
}

export interface ArrayLiteral extends langium.AstNode {
    readonly $container: Literal;
    readonly $type: 'ArrayLiteral';
    vals: Array<Pattern>;
}

export const ArrayLiteral = 'ArrayLiteral';

export function isArrayLiteral(item: unknown): item is ArrayLiteral {
    return reflection.isInstance(item, ArrayLiteral);
}

export interface Attribute extends langium.AstNode {
    readonly $container: Entity | Event | Record;
    readonly $type: 'Attribute';
    name: string;
    properties: Array<Property>;
    type: string;
}

export const Attribute = 'Attribute';

export function isAttribute(item: unknown): item is Attribute {
    return reflection.isInstance(item, Attribute);
}

export interface BinExpr extends langium.AstNode {
    readonly $container: BinExpr | ComparisonExpression | Group | NegExpr | SetAttribute;
    readonly $type: 'BinExpr';
    e1: Expr | PrimExpr;
    e2: Expr | PrimExpr;
    op: '*' | '+' | '-' | '/';
}

export const BinExpr = 'BinExpr';

export function isBinExpr(item: unknown): item is BinExpr {
    return reflection.isInstance(item, BinExpr);
}

export interface ComparisonExpression extends langium.AstNode {
    readonly $container: ComparisonExpression | If;
    readonly $type: 'ComparisonExpression';
    e1: ComparisonExpression | Expr;
    e2: ComparisonExpression | Expr;
    op: '<' | '<=' | '<>' | '=' | '>' | '>=' | 'and' | 'between' | 'in' | 'like' | 'or';
}

export const ComparisonExpression = 'ComparisonExpression';

export function isComparisonExpression(item: unknown): item is ComparisonExpression {
    return reflection.isInstance(item, ComparisonExpression);
}

export interface CrudMap extends langium.AstNode {
    readonly $container: ForEach | Pattern;
    readonly $type: 'CrudMap';
    attributes: Array<SetAttribute>;
    name: string;
    properties: Array<Property>;
    throws?: Throws;
}

export const CrudMap = 'CrudMap';

export function isCrudMap(item: unknown): item is CrudMap {
    return reflection.isInstance(item, CrudMap);
}

export interface Entity extends langium.AstNode {
    readonly $container: Module;
    readonly $type: 'Entity';
    attributes: Array<Attribute>;
    name: string;
}

export const Entity = 'Entity';

export function isEntity(item: unknown): item is Entity {
    return reflection.isInstance(item, Entity);
}

export interface Event extends langium.AstNode {
    readonly $container: Module;
    readonly $type: 'Event';
    attributes: Array<Attribute>;
    name: string;
}

export const Event = 'Event';

export function isEvent(item: unknown): item is Event {
    return reflection.isInstance(item, Event);
}

export interface FnCall extends langium.AstNode {
    readonly $container: Literal;
    readonly $type: 'FnCall';
    args: Array<Literal>;
}

export const FnCall = 'FnCall';

export function isFnCall(item: unknown): item is FnCall {
    return reflection.isInstance(item, FnCall);
}

export interface ForEach extends langium.AstNode {
    readonly $container: ForEach | Pattern;
    readonly $type: 'ForEach';
    patterns: Array<Pattern>;
    src: RawPattern;
    var: string;
}

export const ForEach = 'ForEach';

export function isForEach(item: unknown): item is ForEach {
    return reflection.isInstance(item, ForEach);
}

export interface Group extends langium.AstNode {
    readonly $container: BinExpr | ComparisonExpression | Group | NegExpr | SetAttribute;
    readonly $type: 'Group';
    ge: Expr;
}

export const Group = 'Group';

export function isGroup(item: unknown): item is Group {
    return reflection.isInstance(item, Group);
}

export interface If extends langium.AstNode {
    readonly $container: ForEach | Pattern;
    readonly $type: 'If';
    cond: LogicalExpression;
    patterns: Array<Pattern>;
}

export const If = 'If';

export function isIf(item: unknown): item is If {
    return reflection.isInstance(item, If);
}

export interface Import extends langium.AstNode {
    readonly $container: Module;
    readonly $type: 'Import';
    name: string;
    path: string;
}

export const Import = 'Import';

export function isImport(item: unknown): item is Import {
    return reflection.isInstance(item, Import);
}

export interface KvPair extends langium.AstNode {
    readonly $container: KvPairs;
    readonly $type: 'KvPair';
    key?: string;
    value: Literal;
}

export const KvPair = 'KvPair';

export function isKvPair(item: unknown): item is KvPair {
    return reflection.isInstance(item, KvPair);
}

export interface KvPairs extends langium.AstNode {
    readonly $container: Property;
    readonly $type: 'KvPairs';
    pairs: Array<KvPair>;
}

export const KvPairs = 'KvPairs';

export function isKvPairs(item: unknown): item is KvPairs {
    return reflection.isInstance(item, KvPairs);
}

export interface Literal extends langium.AstNode {
    readonly $container: BinExpr | ComparisonExpression | FnCall | ForEach | Group | KvPair | NegExpr | Pattern | SetAttribute;
    readonly $type: 'Literal';
    val: ArrayLiteral | Boolean | Decimal | FnCall | Ref | string;
}

export const Literal = 'Literal';

export function isLiteral(item: unknown): item is Literal {
    return reflection.isInstance(item, Literal);
}

export interface Module extends langium.AstNode {
    readonly $type: 'Module';
    defs: Array<Def>;
    imports: Array<Import>;
    name: string;
}

export const Module = 'Module';

export function isModule(item: unknown): item is Module {
    return reflection.isInstance(item, Module);
}

export interface NegExpr extends langium.AstNode {
    readonly $container: BinExpr | ComparisonExpression | Group | NegExpr | SetAttribute;
    readonly $type: 'NegExpr';
    ne: Expr;
}

export const NegExpr = 'NegExpr';

export function isNegExpr(item: unknown): item is NegExpr {
    return reflection.isInstance(item, NegExpr);
}

export interface Node extends langium.AstNode {
    readonly $container: Relationship;
    readonly $type: 'Node';
    alias?: string;
    name: string;
}

export const Node = 'Node';

export function isNode(item: unknown): item is Node {
    return reflection.isInstance(item, Node);
}

export interface Pattern extends langium.AstNode {
    readonly $container: ArrayLiteral | ForEach | If | Throws | Workflow;
    readonly $type: 'Pattern';
    alias: Array<string>;
    pat: RawPattern;
}

export const Pattern = 'Pattern';

export function isPattern(item: unknown): item is Pattern {
    return reflection.isInstance(item, Pattern);
}

export interface Property extends langium.AstNode {
    readonly $container: Attribute | CrudMap | Relationship;
    readonly $type: 'Property';
    name: TaggedId;
    value?: KvPairs;
}

export const Property = 'Property';

export function isProperty(item: unknown): item is Property {
    return reflection.isInstance(item, Property);
}

export interface Record extends langium.AstNode {
    readonly $container: Module;
    readonly $type: 'Record';
    attributes: Array<Attribute>;
    name: string;
}

export const Record = 'Record';

export function isRecord(item: unknown): item is Record {
    return reflection.isInstance(item, Record);
}

export interface Relationship extends langium.AstNode {
    readonly $container: Module;
    readonly $type: 'Relationship';
    name: string;
    node1: Node;
    node2: Node;
    properties: Array<Property>;
}

export const Relationship = 'Relationship';

export function isRelationship(item: unknown): item is Relationship {
    return reflection.isInstance(item, Relationship);
}

export interface SetAttribute extends langium.AstNode {
    readonly $container: CrudMap;
    readonly $type: 'SetAttribute';
    name: QueryId;
    value: AttributeValueExpression;
}

export const SetAttribute = 'SetAttribute';

export function isSetAttribute(item: unknown): item is SetAttribute {
    return reflection.isInstance(item, SetAttribute);
}

export interface Throws extends langium.AstNode {
    readonly $container: CrudMap;
    readonly $type: 'Throws';
    handlers: Array<Handler>;
}

export const Throws = 'Throws';

export function isThrows(item: unknown): item is Throws {
    return reflection.isInstance(item, Throws);
}

export interface Workflow extends langium.AstNode {
    readonly $container: Module;
    readonly $type: 'Workflow';
    name: string;
    patterns: Array<Pattern>;
}

export const Workflow = 'Workflow';

export function isWorkflow(item: unknown): item is Workflow {
    return reflection.isInstance(item, Workflow);
}

export type AgentlangAstType = {
    ArrayLiteral: ArrayLiteral
    Attribute: Attribute
    AttributeValueExpression: AttributeValueExpression
    BinExpr: BinExpr
    ComparisonExpression: ComparisonExpression
    CrudMap: CrudMap
    Def: Def
    Entity: Entity
    Event: Event
    Expr: Expr
    FnCall: FnCall
    ForEach: ForEach
    Group: Group
    Handler: Handler
    If: If
    Import: Import
    KvPair: KvPair
    KvPairs: KvPairs
    Literal: Literal
    LogicalExpression: LogicalExpression
    Module: Module
    NegExpr: NegExpr
    Node: Node
    Pattern: Pattern
    PrimExpr: PrimExpr
    Property: Property
    RawPattern: RawPattern
    Record: Record
    Relationship: Relationship
    SchemaDef: SchemaDef
    SetAttribute: SetAttribute
    Throws: Throws
    Workflow: Workflow
}

export class AgentlangAstReflection extends langium.AbstractAstReflection {

    getAllTypes(): string[] {
        return [ArrayLiteral, Attribute, AttributeValueExpression, BinExpr, ComparisonExpression, CrudMap, Def, Entity, Event, Expr, FnCall, ForEach, Group, Handler, If, Import, KvPair, KvPairs, Literal, LogicalExpression, Module, NegExpr, Node, Pattern, PrimExpr, Property, RawPattern, Record, Relationship, SchemaDef, SetAttribute, Throws, Workflow];
    }

    protected override computeIsSubtype(subtype: string, supertype: string): boolean {
        switch (subtype) {
            case BinExpr:
            case PrimExpr: {
                return this.isSubtype(Expr, supertype);
            }
            case ComparisonExpression: {
                return this.isSubtype(LogicalExpression, supertype);
            }
            case CrudMap:
            case ForEach:
            case If: {
                return this.isSubtype(RawPattern, supertype);
            }
            case Entity:
            case Event:
            case Record: {
                return this.isSubtype(SchemaDef, supertype);
            }
            case Expr: {
                return this.isSubtype(AttributeValueExpression, supertype);
            }
            case Group:
            case NegExpr: {
                return this.isSubtype(PrimExpr, supertype);
            }
            case Literal: {
                return this.isSubtype(PrimExpr, supertype) || this.isSubtype(RawPattern, supertype);
            }
            case Pattern: {
                return this.isSubtype(Handler, supertype);
            }
            case Relationship:
            case SchemaDef:
            case Workflow: {
                return this.isSubtype(Def, supertype);
            }
            default: {
                return false;
            }
        }
    }

    getReferenceType(refInfo: langium.ReferenceInfo): string {
        const referenceId = `${refInfo.container.$type}:${refInfo.property}`;
        switch (referenceId) {
            default: {
                throw new Error(`${referenceId} is not a valid reference id.`);
            }
        }
    }

    getTypeMetaData(type: string): langium.TypeMetaData {
        switch (type) {
            case ArrayLiteral: {
                return {
                    name: ArrayLiteral,
                    properties: [
                        { name: 'vals', defaultValue: [] }
                    ]
                };
            }
            case Attribute: {
                return {
                    name: Attribute,
                    properties: [
                        { name: 'name' },
                        { name: 'properties', defaultValue: [] },
                        { name: 'type' }
                    ]
                };
            }
            case BinExpr: {
                return {
                    name: BinExpr,
                    properties: [
                        { name: 'e1' },
                        { name: 'e2' },
                        { name: 'op' }
                    ]
                };
            }
            case ComparisonExpression: {
                return {
                    name: ComparisonExpression,
                    properties: [
                        { name: 'e1' },
                        { name: 'e2' },
                        { name: 'op' }
                    ]
                };
            }
            case CrudMap: {
                return {
                    name: CrudMap,
                    properties: [
                        { name: 'attributes', defaultValue: [] },
                        { name: 'name' },
                        { name: 'properties', defaultValue: [] },
                        { name: 'throws' }
                    ]
                };
            }
            case Entity: {
                return {
                    name: Entity,
                    properties: [
                        { name: 'attributes', defaultValue: [] },
                        { name: 'name' }
                    ]
                };
            }
            case Event: {
                return {
                    name: Event,
                    properties: [
                        { name: 'attributes', defaultValue: [] },
                        { name: 'name' }
                    ]
                };
            }
            case FnCall: {
                return {
                    name: FnCall,
                    properties: [
                        { name: 'args', defaultValue: [] }
                    ]
                };
            }
            case ForEach: {
                return {
                    name: ForEach,
                    properties: [
                        { name: 'patterns', defaultValue: [] },
                        { name: 'src' },
                        { name: 'var' }
                    ]
                };
            }
            case Group: {
                return {
                    name: Group,
                    properties: [
                        { name: 'ge' }
                    ]
                };
            }
            case If: {
                return {
                    name: If,
                    properties: [
                        { name: 'cond' },
                        { name: 'patterns', defaultValue: [] }
                    ]
                };
            }
            case Import: {
                return {
                    name: Import,
                    properties: [
                        { name: 'name' },
                        { name: 'path' }
                    ]
                };
            }
            case KvPair: {
                return {
                    name: KvPair,
                    properties: [
                        { name: 'key' },
                        { name: 'value' }
                    ]
                };
            }
            case KvPairs: {
                return {
                    name: KvPairs,
                    properties: [
                        { name: 'pairs', defaultValue: [] }
                    ]
                };
            }
            case Literal: {
                return {
                    name: Literal,
                    properties: [
                        { name: 'val' }
                    ]
                };
            }
            case Module: {
                return {
                    name: Module,
                    properties: [
                        { name: 'defs', defaultValue: [] },
                        { name: 'imports', defaultValue: [] },
                        { name: 'name' }
                    ]
                };
            }
            case NegExpr: {
                return {
                    name: NegExpr,
                    properties: [
                        { name: 'ne' }
                    ]
                };
            }
            case Node: {
                return {
                    name: Node,
                    properties: [
                        { name: 'alias' },
                        { name: 'name' }
                    ]
                };
            }
            case Pattern: {
                return {
                    name: Pattern,
                    properties: [
                        { name: 'alias', defaultValue: [] },
                        { name: 'pat' }
                    ]
                };
            }
            case Property: {
                return {
                    name: Property,
                    properties: [
                        { name: 'name' },
                        { name: 'value' }
                    ]
                };
            }
            case Record: {
                return {
                    name: Record,
                    properties: [
                        { name: 'attributes', defaultValue: [] },
                        { name: 'name' }
                    ]
                };
            }
            case Relationship: {
                return {
                    name: Relationship,
                    properties: [
                        { name: 'name' },
                        { name: 'node1' },
                        { name: 'node2' },
                        { name: 'properties', defaultValue: [] }
                    ]
                };
            }
            case SetAttribute: {
                return {
                    name: SetAttribute,
                    properties: [
                        { name: 'name' },
                        { name: 'value' }
                    ]
                };
            }
            case Throws: {
                return {
                    name: Throws,
                    properties: [
                        { name: 'handlers', defaultValue: [] }
                    ]
                };
            }
            case Workflow: {
                return {
                    name: Workflow,
                    properties: [
                        { name: 'name' },
                        { name: 'patterns', defaultValue: [] }
                    ]
                };
            }
            default: {
                return {
                    name: type,
                    properties: []
                };
            }
        }
    }
}

export const reflection = new AgentlangAstReflection();
