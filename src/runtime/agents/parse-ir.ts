/* Parse the JSON intermediate representation generated by planner-agents to proper Agentlang workflows */

import { isString } from '../util.js';

export function workflowFromJson(json: string): string {
  const obj = JSON.parse(json);
  const wf: any | undefined = obj.workflow;
  if (wf && !wf.event) {
    throw new Error('workflow name not specified in generated JSON');
  }
  const pObjs: any[] | undefined = wf?.patterns || obj.patterns;
  if (pObjs === undefined) {
    throw new Error('No patterns found in generater JSON');
  }
  const pats = pObjs
    .map((patObj: any) => {
      return parsePattern(patObj);
    })
    .join(';\n');

  if (wf === undefined) {
    return `[${pats}]`;
  } else {
    return `workflow ${wf.event} {
        ${pats}
     }`;
  }
}

function parsePattern(pObj: any): string {
  if (pObj.create) {
    return parseCreate(pObj);
  } else if (pObj.query) {
    return parseQuery(pObj);
  } else if (pObj.update) {
    return parseUpdate(pObj);
  } else if (pObj.delete) {
    return parseDelete(pObj);
  } else if (pObj.if) {
    return parseIf(pObj);
  } else if (pObj.for) {
    return parseFor(pObj);
  } else {
    throw new Error(`Invalid pattern object: ${pObj}`);
  }
}

function parseCreate(pObj: any): string {
  const n: string = pObj.create;
  const attrs = asAttributes(pObj.with);
  const result = `{${n} {
    ${attrs}`;
  return maybeAddAlias(pObj, maybeAddRelationships(pObj, result));
}

function parseUpdate(pObj: any): string {
  const n: string = pObj.update;
  const attrs = asAttributes(pObj.set);
  const qattrs = asQueryAttributes(pObj.where);
  const result = `{${n} {
    ${qattrs},
    ${attrs}`;
  return maybeAddAlias(pObj, maybeAddRelationships(pObj, result));
}

function parseDelete(pObj: any): string {
  const result = parseQuery(pObj);
  return `delete ${result}`;
}

function parseQuery(pObj: any): string {
  const n = pObj.query || pObj.delete;
  const where: any = pObj.where;
  let result = '';
  if (where) {
    result = `{${n}? {`;
  } else {
    result = `{${n} {
        ${asQueryAttributes(where)}`;
  }
  return maybeAddAlias(pObj, maybeAddRelationships(pObj, result));
}

function parseIf(pObj: any): string {
  if (pObj) throw new Error(`parseIf not implemented`);
  return '';
}

function parseFor(pObj: any): string {
  if (pObj) throw new Error(`parseFor not implemented`);
  return '';
}

function asAttributes(attrsObj: any): string {
  if (attrsObj === undefined) {
    attrsObj = {};
  }
  return Object.keys(attrsObj)
    .map((k: string) => {
      const spec: any = attrsObj[k];
      const v: any = asAttributeValue(spec);
      return `${k} ${v}`;
    })
    .join(',\n');
}

function asQueryAttributes(whereObj: any): string {
  return Object.keys(whereObj)
    .map((k: string) => {
      const q: any = whereObj[k];
      const opr = Object.keys(q)[0];
      const v: any = asAttributeValue(q[opr]);
      if (opr === '=') {
        return `${k}? ${v}`;
      } else {
        return `${k}?${opr} ${v}`;
      }
    })
    .join(',\n');
}

function asAttributeValue(spec: any): any {
  let v: any = spec.ref || spec.expr;
  if (v === undefined) {
    v = spec.val;
    if (isString(v)) {
      v = `"${v}"`;
    }
  }
  return v;
}

function maybeAddAlias(pObj: any, result: string): string {
  const alias: string | undefined = pObj.as;
  if (alias === undefined) return result;
  else return `${result} @as ${alias}`;
}

function maybeAddRelationships(pObj: any, result: string): string {
  const links: any[] | undefined = pObj.links;
  if (links === undefined) {
    return `${result}}}`;
  }
  const rels = links.map((spec: any) => {
    const r: string | undefined = spec.relationship;
    if (r === undefined) {
      throw new Error(`Relationship name is required in ${spec}`);
    }
    const s = parsePattern(spec);
    return `${r} ${s}`;
  });
  return `${result},\n${rels.join(',\n')}}}`;
}
