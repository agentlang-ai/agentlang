/* Parse the JSON intermediate representation generated by planner-agents to proper Agentlang workflows */

import { isString } from '../util.js';

export function parseJsonIR(json: any): string[] {
  const obj = isString(json) ? JSON.parse(json) : json;
  const wf: any | undefined = obj.workflow;
  if (wf && !wf.event) {
    throw new Error('workflow name not specified in generated JSON');
  }
  const pObjs: any[] | undefined = wf?.patterns || obj.patterns;
  if (pObjs === undefined) {
    throw new Error('No patterns found in generated JSON');
  }
  const pats = pObjs.map((patObj: any) => {
    return parsePattern(patObj);
  });

  if (wf === undefined) {
    return pats;
  } else {
    return [
      `workflow ${wf.event} {
        ${pats.join(';\n')}
     }`,
    ];
  }
}

function parsePattern(pObj: any): string {
  if (pObj.create) {
    return parseCreate(pObj);
  } else if (pObj.query) {
    return parseQuery(pObj);
  } else if (pObj.update) {
    return parseUpdate(pObj);
  } else if (pObj.delete) {
    return parseDelete(pObj);
  } else if (pObj.if) {
    return parseIf(pObj.if);
  } else if (pObj.for) {
    return parseFor(pObj.for);
  } else if (pObj.val) {
    return asAttributeValue(pObj);
  } else if (pObj.ref) {
    return pObj.ref;
  } else {
    throw new Error(`Invalid pattern object: ${pObj}`);
  }
}

function parseCreate(pObj: any): string {
  const n: string = pObj.create;
  const attrs = asAttributes(pObj.with);
  const result = `{${n} {
    ${attrs}`;
  return maybeAddAlias(pObj, maybeAddRelationships(pObj, result));
}

function parseUpdate(pObj: any): string {
  const n: string = pObj.update;
  const attrs = asAttributes(pObj.set);
  const qattrs = asQueryAttributes(pObj.where);
  const result = `{${n} {
    ${qattrs},
    ${attrs}`;
  return maybeAddAlias(pObj, maybeAddRelationships(pObj, result));
}

function parseDelete(pObj: any): string {
  const result = parseQuery(pObj);
  return `delete ${result}`;
}

function parseQuery(pObj: any): string {
  const n = pObj.query || pObj.delete;
  const where: any = pObj.where;
  let result = '';
  if (where === undefined) {
    result = `{${n}? {`;
  } else {
    result = `{${n} {
        ${asQueryAttributes(where)}`;
  }
  result = maybeAddInto(pObj, result);
  return maybeAddAlias(pObj, maybeAddRelationships(pObj, result));
}

function parseCondition(c: any): string {
  const opr = Object.keys(c)[0];
  if (opr === 'and' || opr === 'or') {
    return c[opr]
      .map((cc: any) => {
        return parseCondition(cc);
      })
      .join(` ${opr} `);
  } else {
    const vals = c[opr].map((v: any) => {
      return parsePattern(v);
    });
    return vals.join(` ${opr} `);
  }
}

function parseIf(pObj: any): string {
  const cond = parseCondition(pObj.condition);
  const then = pObj.then.map((v: any) => {
    return parsePattern(v);
  });
  const else_ = pObj.else?.map((v: any) => {
    return parsePattern(v);
  });
  const alias = pObj.as;
  let result = `if (${cond[0]}) {
      ${then.join(';\n')}
  }`;
  if (else_) {
    result = `${result} else {\n
        ${else_.join(';\n')}
    }`;
  } else {
    result = result;
  }
  if (alias) {
    return `${result} @as ${alias}`;
  }
  return result;
}

function parseFor(pObj: any): string {
  const each = parsePattern(pObj.each);
  const v = pObj.in;
  const body = pObj.do.map((v: any) => {
    return parsePattern(v);
  });
  const result = `for ${v} in ${each} {
      ${body.join(';\n')}
  }`;
  const alias = pObj.as;
  if (alias) {
    return `${result} @as ${alias}`;
  }
  return result;
}

function asAttributes(attrsObj: any): string {
  if (attrsObj === undefined) {
    attrsObj = {};
  }
  return Object.keys(attrsObj)
    .map((k: string) => {
      const spec: any = attrsObj[k];
      const v: any = asAttributeValue(spec);
      return `${k} ${v}`;
    })
    .join(',\n');
}

function asQueryAttributes(whereObj: any): string {
  return Object.keys(whereObj)
    .map((k: string) => {
      const q: any = whereObj[k];
      const opr = Object.keys(q)[0];
      const v: any = asAttributeValue(q[opr]);
      if (opr === '=') {
        return `${k}? ${v}`;
      } else {
        return `${k}?${opr} ${v}`;
      }
    })
    .join(',\n');
}

function asAttributeValue(spec: any): any {
  let v: any = spec.ref || spec.expr;
  if (v === undefined) {
    v = spec.val;
    if (isString(v)) {
      v = `"${v}"`;
    }
  }
  return v;
}

function maybeAddAlias(pObj: any, result: string): string {
  const alias: string | undefined = pObj.as;
  if (alias === undefined) return result;
  else return `${result} @as ${alias}`;
}

function maybeAddRelationships(pObj: any, result: string): string {
  const links: any[] | undefined = pObj.links;
  if (links === undefined) {
    return `${result}}}`;
  }
  const rels = links.map((spec: any) => {
    const r: string | undefined = spec.relationship;
    if (r === undefined) {
      throw new Error(`Relationship name is required in ${spec}`);
    }
    const s = parsePattern(spec);
    return `${r} ${s}`;
  });
  return `${result}},\n${rels.join(',\n')}}`;
}

function maybeAddInto(pObj: any, result: string): string {
  const into: any = pObj.into;
  if (into === undefined) {
    return result;
  } else {
    const r = Object.keys(into).map((k: string) => {
      const spec: any = into[k];
      let v = '';
      if (spec.ref || spec.val || spec.expr) {
        v = asAttributeValue(spec);
      } else {
        const f = Object.keys(spec)[0];
        v = `@${f}(${asAttributeValue(spec[f])})`;
      }
      return `${k} ${v}`;
    });
    return `${result},\n@into {${r.join(', ')}}`;
  }
}
