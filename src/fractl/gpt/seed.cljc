(ns fractl.gpt.seed)

(def conversation
  [{:role "system" :content "You are the fractl assistant."},
   {:role "user" :content "Model a blog application."},
   {:role "assistant" :content "(component :Blog.Core) (entity :Blog.Core/Post {:Title :String :Content :String :CreatedBy :String :CreatedOn :String}) (entity :Blog.Core/Comment {:Title :String :Content :String :CreatedBy :String :CreatedOn :String})"},
   {:role "user" :content "As :Post and :Comment share a common structure, they can be inherited from a common record"},
   {:role "assistant" :content "(record :Blog.Core/BlogEntry {:Title :String :Content :String :CreatedBy :String :CreatedOn :String}) (entity :Blog.Core/Post {:meta {:inherits :Blog.Core/BlogEntry}}) (entity :Blog.Core/Comment {:meta {:inherits :Blog.Core/BlogEntry}})"},
   {:role "user" :content "Good! it would help to make :CreatedBy an email attribute and :CreatedOn to default to the current date-time"},
   {:role "assistant" :content "(record :Blog.Core/BlogEntry {:Title :String :Content :String :CreatedBy :Email :CreatedOn :Now})"},
   {:role "user" :content "Can we add a unique identity for :BlogEntry and also make it searchable by :Title and :CreatedBy?"},
   {:role "assistant" :content "(record :Blog.Core/BlogEntry {:Title {:type :String :indexed true} :Content :String :CreatedBy {:type :Email :indexed true} :CreatedOn :Now})"},
   {:role "user" :content "Perfect! can the :Comments be contained under :Posts?"},
   {:role "assistant" :content "(relationship :Blog.Core/CommentOf {:meta {:contains [:Blog.Core/Post :Blog.Core/Comment]}})"},
   {:role "user" :content "How can I lookup-up :Posts created by a particular author?"},
   {:role "assistant" :content "(dataflow :Blog.Core/PostsBy {:Blog.Core/Post {:CreatedBy? :Blog.Core/PostsBy.Author}})"}
   {:role "user" :content "Can you generate an accounting application?"}
   {:role "assistant" :content "(component :Accounts.Core {:clj-import '[(:require [clojure.string :as s])]}) (attribute :Accounts.Core/UniqueName {:type :String :identity true}) (defn- image-url? [s] (and (string? s) true)) (def lower-case s/lower-case) (attribute :Accounts.Core/Image {:check image-url?}) (entity :Accounts.Core/Company {:Name :Accounts.Core/UniqueName :Logo :Accounts.Core/Image}) (dataflow :Accounts.Core/CreateCompany {:Accounts.Core/Company {:Name '(lower-case :Accounts.Core/CreateCompany.Instance.Name) :Logo :Accounts.Core/CreateCompany.Instance.Logo}}) (entity :Accounts.Core/AccountHead :Name :Accounts.Core/UniqueName :Type {:oneof [:income :expense] :default :expense}}) (relationship :Accounts.Core/CompanyAccount {:meta {:contains [:Accounts.Core/Company :Accounts.Core/AccountHead]}}) (relationship :Accounts.Core/Transaction {:meta {:between [:Accounts.Core/AccountHead :Accounts.Core/AccountHead :as [:Debit :Credit] :cascade-on-delete true]} :Amount :Decimal :Date :Now :Comments {:type :String :optional true}}) (event :Accounts.Core/TransactionReport {:StartDate :DateTime :EndDate :DateTime}) (dataflow :Accounts.Core/TransactionReport {:Accounts.Core/Transaction? {:where [:and [:>= :Date :Accounts.Core/TransactionReport.StartDate] [:<= :Date :Accounts.Core/TransactionReport.EndDate]]}})"}
   {:role "user" :content "That's great. I see you defined a custom :CreateCompany dataflow because a user-defined transformation is required for the :Name attribute. Do you know what built-in types are allowed for attributes?"}
   {:role "assistant" :content "Yes. :String, :Keyword, :Path, :DateTime, :Date, :Time, :UUID, :Int, :Int64, :BigInteger, :Float, :Double, :Decimal, :Boolean, :Record, :Entity, :Event, :Any, :Email, :Password, :Map, :Edn, :Identity, :Now. :Identity can be used for auto-generated UUID values."}
   {:role "user" :content "An attribute can be declared as a collection or enumeration with the following properties - (1) :listof - a sequence of objects belonging to the specified type.  (2) :setof - a set of objects belonging to the specified type, duplicates are ignored. (3) :oneof - specifies a list of values for the attribute, making it into an enumerated type."}
   {:role "assistant" :content "Can you show me an example?"}
   {:role "user" :content "(entity :Acme/Person {:Name :String :Age :Int :Sex {:oneof [\"male\" \"female\"]}})"}
   {:role "assistant" :content "Thanks. What other constraints are valid for attributes?"}
   {:role "user" :content "All constraints accepted by attribute definitions are explained below. :default - the value to use, if the attribute is not set. :optional - the attribute value is optional, default to nil. :check - a Clojure predicate that return true if the attribute value passes a constraint check, return false otherwise. :unique- ensure that the attribute value is unique across all instances of the record, applicable only for entities. :indexed - setup an index on the attribute for queries, applicable only to entities. :identity - unique identity attribute. :immutable - once set, the attribute value cannot be changed. applicable only to entities. :format - ensure the attribute value conforms to the specified regular expression. :write-only - if true, the attribute value will not be returned by a lookup or query. :encryption - encrypt the attribute value using the specified encryption algorithm, currently the only supported value is :default which selects the best available algorithm. :type-in-store - a string that identifies a storage-level type (e.g \"VARCHAR (80)\"), if not specified the best type is selected by the platform. applicable only to entities. :ref (deprecated) - path to an indexed attribute of another entity, works similar to a foreign-key relationship in an RDBMS. :var - if set to true, attribute will behave like a mutable variable that has to be dereferenced to fetch the actual value. :writer - a Clojure function that serializes the attributes value, if not specified an appropriate serializer is selected by the platform. applicable only to entities. Example: (attribute :Acme/Url {:type :String :indexed true :immutable true})"}
   {:role "user" :content "I think you can generate fairly complex models now. Keep in mind that only instances of entities can be persisted and only entities can become part of relationships"}
   {:role "assistant" :content "Yes"}
   {:role "user" :content "Show me an example of a dataflow for creating a new instance of an entity from another entity"}
   {:role "assistant" :content "(dataflow :Acme/CreateEfromA {:E {:Id? :Acme/CreateEfromA.E} :as :E} {:A {:X :E.V :Y 100}})"}
   {:role "user" :content "What if more than one instance needs to be queried and created?"}
   {:role "assistant" :content "(dataflow :Acme/CreateEfromA {:E {:V? [:>= :Acme/CreateEfromA.V]} :as :Es} [:for-each :Es {:A {:X :%.V :Y 100}}])"}])
